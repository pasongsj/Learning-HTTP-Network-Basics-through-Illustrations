# HTTP METHOD

## HTTP request methods
### 속성
**안전한 메서드(Safe)**
- 안전한 메서드는 서버의 상태를 변경하지 않는 HTTP 메서드를 의미
- 서버의 데이터를 수정하거나 상태를 변경하지 않으며, 주로 정보를 조회하거나 읽는 데 사용
- **특징**
    - 같은 요청을 여러 번 보내도 결과가 변하지 않는다
    - ex GET, HEAD, OPTIONS 등
- **멱등성과 안전한 메서드의 차이**
    - 모든 안전한 메서드는 멱등성을 가지고 있지만, 모든 멱등성 메서드가 안전한 것은 아니다.
        - 안전한 메서드는 요청을 여러 번 보내도 결과가 동일하며 서버에 미치는 영향이 없다.
        - PUT과 DELETE는 멱등성을 가지고 있지만, 서버의 상태를 변경할 수 있어, 안전한 메서드는 아니다.
            - ex `PUT` 요청은 자원을 덮어쓰고, `DELETE`는 자원을 삭제하므로 서버의 상태가 변경된다.

**멱등성(Idempotency)**
- 동일한 요청을 여러 번 보내도 서버에 미치는 효과가 동일
- **DELETE**는 멱등성을 가지고 있지만, 상태 코드가 달라질 수 있다.
    - ex 이미 삭제된 리소스를 삭제하려 하면 `404 Not Found` 상태 코드가 반환될 수 있지만, 여전히 서버의 상태에는 영향이 없다.

**캐시(Cache)**
- 캐시 가능한 응답은 나중에 다시 사용할 수 있도록 저장되는 HTTP 응답을 의미
- **웹 캐시 종류**
    - 브라우저 캐시
        - 사용자의 브라우저가 웹 페이지나 리소스를 저장하여 이후 동일한 요청 시 서버에 요청하지 않고 로컬에서 데이터를 제공하는 방식
    - 프록시 캐시
        - 클라이언트와 서버 사이에 위치한 서버(예: CDN)가 캐시 데이터를 저장하여 여러 사용자가 같은 데이터에 빠르게 접근할 수 있도록 돕는다.
    - 서버 캐시
        - 서버 측에서 데이터를 저장하고, 클라이언트 요청이 있을 때마다 빠르게 응답할 수 있도록 캐시를 사용
- 캐시 관련 HTTP 헤더
    - **Cache-Control**
        - 캐시를 어떻게 처리할지에 대한 지침을 제공
        - 예: `Cache-Control: no-cache` (캐시를 사용하지 않도록), `Cache-Control: max-age=3600` (1시간 동안 캐시 가능)
    - Expires
        - 캐시된 데이터가 만료될 시간을 설정합니다. 주로 `Cache-Control`이 널리 사용되지만, `Expires`도 여전히 지원
    - ETag
        - 리소스의 버전을 나타내는 값으로, 리소스가 변경되었는지 확인할 때 사용된다.
        - ETag 값이 다르면 캐시를 새로 갱신
    - **Last-Modified**:
        - 리소스가 마지막으로 수정된 시간을 표시하며, 클라이언트는 이 정보를 바탕으로 서버에 리소스가 변경되었는지 확인
- **제약조건**
    - **캐시 가능한 응답**은 주로 **GET**이나 **HEAD** 요청에 대해 발생한다.
    - **POST**, **PUT**, **DELETE**와 같은 요청에 대한 응답은 일반적으로 캐시할 수 없다.
      - PUT 요청은 서버 상태를 변경하므로 이전에 캐시된 GET 또는 HEAD 응답을 무효화한다.
    - 캐시 가능한 응답의 **상태 코드**
        - `200 OK`, `203 Non-Authoritative Information`, `204 No Content`, `206 Partial Content`, `300 Multiple Choices`, `301 Moved Permanently`, `404 Not Found`, `405 Method Not Allowed`, `410 Gone`, `414 URI Too Long`, `501 Not Implemented`
    - **Cache-Control: no-cache**와 같은 헤더가 있으면 해당 응답은 캐시되지 않는다.
<br>

### GET
GET 요청은 데이터를 조회하는 용도로만 사용되며, 요청 본문은 포함되지 않는다.
**메시지 본문을 포함할 경우**
* GET 요청에 데이터가 포함되면 서버가 이를 잘못된 요청으로 판단하고, 4XX 클라이언트 오류를 발생시킬 수 있다.

![image](https://github.com/user-attachments/assets/9b78e98e-4cb4-463d-8762-066e9465325c)  
<br>

### HEAD
* GET 요청과 동일하게 서버에 리소스를 요청하지만, 본문(body)을 포함하지 않고 오직 헤더만 반환한다.
* 서버가 반환하는 메타데이터를 통해 리소스의 정보(예: 콘텐츠 타입, 길이, 마지막 수정 시간 등)를 확인하려는 경우에 유용하다.
  * 실제 콘텐츠를 다운로드할 필요가 없을 때, 리소스에 대한 정보를 확인하려는 목적에 사용된다.
* 서버는 헤더만 포함된 200 OK 응답을 반환한다.

![image](https://github.com/user-attachments/assets/36efce1f-5b38-4f4e-a675-d617e6f83754)  
<br>

### Options
* 특정 URL 또는 서버에 대해 어떤 HTTP 메서드가 허용되는지 확인할 때 사용된다.
  * ex 특정 URL에 대해 OPTIONS /resource 또는 OPTIONS *를 사용하여 서버가 허용하는 메서드를 확인 가능
* 클라이언트가 다른 출처의 서버와 통신하기 전에, 서버가 허용하는 메서드나 헤더를 확인하는 데 사용된다.
  * 실제 요청을 보내기 전에 서버의 정책을 파악 가능

![image](https://github.com/user-attachments/assets/533626e6-2560-4cad-b9fd-d66e3bf25584)  
<br>

### POST
* 클라이언트에서 서버로 데이터를 전송할 때 주로 사용되는 HTTP 메서드
* 다양한 기능을 처리할 수 있는 범용적인 HTTP 메서드로, 특히 서버에서 데이터를 처리하거나 상태를 변경하는 작업에 주로 사용
* PUT과는 다르게 동일한 요청을 여러 번 보낼 경우 부수 효과(side effect)가 발생할 수 있다.
  * ex POST 요청을 여러 번 보내면 동일한 데이터를 여러 번 생성하거나 변경할 수 있다.
* HTML 폼은 데이터를 서버로 전송할 때 일반적으로 POST 방식을 사용한다.

![image](https://github.com/user-attachments/assets/c321c21d-771c-49a0-9992-61580cc4d4d1)  
<br>

### PUT
* 서버에 데이터 추가나 기존 데이터 수정을 위해 사용된다.
* PUT 요청은 멱등성을 가진다. 즉, 동일한 요청을 여러 번 보낸다고 해도 결과가 동일하다.
  * 첫 번째 요청에서 리소스를 생성하거나 수정하면, 그 후 동일한 요청을 반복하더라도 서버의 상태는 변하지 않는다.
  * ex PUT /users/123 요청을 보내면 ID가 123인 사용자의 정보가 업데이트된다. 이 요청을 여러 번 보내더라도 결과는 동일

**서버 상태**
* PUT 요청이 성공적으로 표현을 생성한 경우, 원본 서버는 201 Created 응답을 반환한다.
* 요청을 통해 리소스의 데이터를 수정했다면, 서버는 요청이 성공적으로 처리되었음을 200 OK(수정 완료) 또는 204 No Content(수정 완료, 본문 없음)로 응답한다.

![image](https://github.com/user-attachments/assets/ca707bf7-9755-4fc5-963b-ae10dbb07f7e)  
<br>

### PATCH
* 리소스를 전체적으로 교체하지 않고, 수정하려는 부분만 변경하는 메서드이다.
  * ex 사용자의 일부 정보만 업데이트하거나, 게시글의 내용 일부만 수정하는 경우에 사용
* PATCH 요청은 POST와 마찬가지로, 요청을 보내는 자원 외에도 다른 자원에 부수효과(side effect)를 미칠 수 있다.

**PUT과 비교**
PUT 요청을 여러 번 보내도 결과가 변하지 않지만, PATCH는 부분적인 교체이므로 멱등성을 보장하지 않는다.

**브라우저 호환성**
* PATCH 메서드는 브라우저에서 사용자 동작(예: 버튼 클릭, 폼 제출)으로 직접 실행되지 않는다.
  * 즉, 기본적인 HTML 폼에서는 PATCH 요청을 보낼 수 없다.
* JavaScript의 fetch() 함수를 사용하여 PATCH 요청을 수동으로 보낼 수 있다.

![image](https://github.com/user-attachments/assets/f4328d5c-515a-48a4-bbdb-0268ac7daae0)  
<br>

### Delete
* 서버에 지정된 리소스를 삭제하도록 요청하는 HTTP 메서드이다.
* 멱등성을 가지므로, 동일한 요청을 여러 번 보내도 결과가 달라지지 않는다.

**서버 상태**
* 204 No Content
  * DELETE 요청 후 리소스가 삭제되었음을 나타낼 때 사용
* 200 OK
  * 응답은 요청이 성공적이었으며 응답 본문에 결과를 설명하는 표현이 포함되어 있음을 의미
* 202 Accepted
  * 주로 비동기 작업에서 사용되며, 요청이 성공적으로 처리될 것 같지만 아직 서버에서 완료되지 않은 경우에 사용

![image](https://github.com/user-attachments/assets/7a2319f4-c7af-427a-8440-0444d465f43f)  
<br>

### Trace
* 주로 개발자가 서버와의 요청 및 응답을 점검하기 위해 사용된다.
  * 요청이 네트워크 경로를 따라 각 서버에서 어떻게 처리되는지 확인
* 클라이언트가 서버로 보낸 요청이 그대로 반환되도록 하여 루프백 테스트(echo) 용도로 사용
  * 서버는 요청을 그대로 응답 본문에 포함하여 200 OK 상태 코드와 함께 반환된다..
  * 응답 본문은 Content-Type: message/http 형식으로 제공된다.

**서버 보안상의 문제**
* 많은 서버에서는 보안상의 이유로 TRACE 메서드를 비활성화하거나 제한적으로만 사용된다.
* 보안이 취약한 서버에서는 TRACE 메서드에 대해 405 Method Not Allowed 클라이언트 오류 응답이 반환될 수 있다.
* XST (Cross-Site Tracing) 공격
  * TRACE 메서드를 통해 세션 정보나 쿠키와 같은 민감한 데이터를 탈취할 수 있는 취약점이 존재
  * HttpOnly 속성이 적용된 쿠키는 자바스크립트로 접근할 수 없지만, TRACE 응답을 통해 세션 정보를 탈취
  * 공격자는 악성 스크립트를 작성하여 피해자가 TRACE 요청을 통해 세션 정보를 유출하도록 유도
  * 최신 브라우저에서는 보안 정책으로 인해 XHR 요청을 통한 TRACE 메서드 실행이 불가능하므로, 해당 취약점은 현재 발생 확률이 낮다.
 
**브라우저 호환성**
* 웹 브라우저에서는 직접적으로 사용되지 않으며, 일반적인 사용자 동작으로는 실행되지 않는다.
* 개발자는 fetch()와 같은 JavaScript 함수를 사용하여 TRACE 요청을 수동으로 설정할 수 있다.

![image](https://github.com/user-attachments/assets/aa7aa59a-3ae4-41ac-8afa-1fc62e98c92f)  
<br>

### CONNECT  
* HTTP 프록시 서버에 터널을 열어 달라고 요청하는 방식
  * 이 요청을 통해 클라이언트는 프록시 서버를 사용하여 보안 연결(예: HTTPS)을 설정
  * 터널이 성공적으로 설정되면, 프록시 서버는 클라이언트와 서버 간에 데이터를 양방향으로 전달한다.
* CONNECT 요청은 대상 서버의 호스트와 포트 번호만을 포함한다.
  * ex example.com:443

**보안 연결 (TLS/HTTPS)**
* CONNECT 메서드는 클라이언트가 프록시를 통해 TLS(HTTPS) 연결을 설정할 수 있도록 돕는 역할
* CONNECT 메서드는 HTTPS 프로토콜을 통해 SSH, FTP와 같은 제한된 트래픽을 전달할 수 있다.
* TLS(Transport Layer Security)는 온라인 네트워크에서 데이터를 안전하게 주고받기 위한 암호화 프로토콜
  * HTTPS 연결을 설정하고 데이터를 암호화하여 중간에서 데이터를 가로채도 복호화할 수 없다.
  * 연결 과정
    1. 클라이언트는 프록시 서버에 대상 서버로의 TCP 연결을 요청하고 터널을 열도록 요청
    2. 프록시 서버는 대상 서버에 보안 연결을 설정
    3. 연결이 성공적으로 이루어지면, 프록시 서버는 클라이언트와 서버 간의 양방향 전송

**홉별 메서드**  
![image](https://github.com/user-attachments/assets/928173f2-c2cf-4926-a9a8-0717916f083c)  
홉 바이 홉(Hop-by-Hop) 통신은 패킷이 최종 목적지에 도달할 때까지 여러 라우터를 거쳐 가는 과정을 의미한다. 
여기서 **홉(hop)**은 각 라우터나 네트워크 장치를 의미하며, 각 패킷이 통과하는 라우터를 하나의 홉으로 간주한다. 그리고,
CONNECT는 홉별(hop-by-hop) 메서드이다. 이는, CONNECT 요청이 중간에 다른 프록시 서버를 거쳐야만 제대로 동작한다는 것을 의미한다.  

**라우팅 과정**
* 패킷은 라우팅 테이블을 통해 출발지 IP부터 시작하여 각 홉을 거쳐 다음 IP로 이동하며, 최종 목적지에 도달한다.
  * 이 과정에서 각 홉은 중간 라우터나 서버가 해당 패킷을 다음 목적지로 전달하는 역할
<br>

## 참고
### [MDN](https://developer.mozilla.org/en-US/)
### [**TLS(Transport Layer Security)**](https://docs.tosspayments.com/resources/glossary/tls)
### [**XST(Cross-Site Tracing) - HTTP TRACE 메소드 취약점**](https://jdh5202.tistory.com/959)
### [**면접을 위한 CS 전공지식 노트**(https://thebook.io/080326)](https://thebook.io/080326/0111/)

  
  



