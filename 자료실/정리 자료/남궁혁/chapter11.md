# 제 11장 웹 공격 기술

## 11.1 웹 공격 기술
* HTTP를 사용하는 서버, 클라이언트, 웹 애플리케이션 등의 리소스를 대상으로 보안 공격을 수행한다.

### HTTP에는 보안 기능이 없다.
**문제점**
- **데이터를 평문(plain text)으로 전송**
    - 클라이언트와 서버 간에 주고받는 모든 데이터가 암호화되지 않기 때문에, 중간에서 누군가가 데이터를 가로채서 읽거나 분석할 수 있다.
        - 웹 서버와 클라이언트 간의 모든 요청과 응답을 노출시키므로, 악의적인 공격자가 통신 내용, 요청 헤더, 쿠키 등을 쉽게 확인
- **데이터 무결성 보장 X**
    - 전송된 데이터가 중간에서 변조되었는지 확인하는 메커니즘을 제공하지 않는다.
        - 중간에서 데이터를 변조할 수 있는 **Man-in-the-Middle(MITM) 공격**에 취약하기 때문에, 공격자가 사용자와 서버 사이에 끼어들어 데이터를 수정한 후 정상적인 통신인 것처럼 보이게 만들 수 있다.
- **인증 및 신뢰성 부족**
    - 서버가 누구인지, 서버가 정확히 신뢰할 수 있는 곳인지 확인하지 않는다.
        - **Phishing(피싱)** 공격에 취약하다. 공격자는 사용자에게 가짜 웹사이트를 만들고 실제 웹사이트처럼 보이게 할 수 있으며, 사용자는 이를 통해 자신의 민감한 정보를 입력할 수 있다.

**해결방법**
- HTTP는 이러한 문제를 해결하기 위해 HTTPS(SSL/TLS) 암호화와 인증을 사용하여 웹 통신을 안전하게 보호한다.
- SSH
    - 네트워크를 통해 안전하게 원격 시스템에 접속하고 명령을 실행할 수 있도록 해주는 프로토콜로서 주로 서버 관리, 원격 로그인, 파일 전송 등에 사용
    - **암호화된 통신**을 제공하여 데이터가 전송되는 동안 보안을 보장
        - 클라이언트와 서버 간의 모든 데이터 전송을 암호화하여, 네트워크 상에서 정보가 노출되는 것을 방지한다.
        - 위에서 언급한 중간자 공격(Man-in-the-Middle)을 막을 수 있다.
    - 두 가지 주요 인증 방법을 지원
        - 사용자가 서버에 로그인할 때 **패스워드**를 ****입력하여 인증
        - 비대칭키 전략
            - 서버는 클라이언트의 공개키를 알고 있고, 클라이언트는 개인키로 인증을 수행
    - **SSL/TLS와 차이**
        - 모두 보안을 제공하는 프로토콜이지만, 각각의 목적과 사용되는 방식에서 차이가 있다.
        - **SSH (Secure Shell)**
            - SSH는 서버와 클라이언트 간의 **암호화된 원격 접속**을 위한 프로토콜
            - 주로 **원격 로그인**과 **원격 명령 실행**을 위해 사용
        - **TLS (Transport Layer Security)**
            - TLS는 네트워크 상에서 데이터가 안전하게 전송될 수 있도록 **암호화, 인증, 무결성 보장**을 제공
            - 주로 **애플리케이션 계층의 통신 보안**을 위해 사용된다. HTTPS, 이메일, VoIP 등 다양한 프로토콜에서 사용
        ![Image](https://github.com/user-attachments/assets/1c23b952-5dfa-4d37-987f-17a26cc6010c)  

### 리퀘스트는 클라이언트에서 변조 가능
- 웹 애플리케이션에 대한 공격은 **HTTP 요청 메시지**를 통해 이루어진다.
- 공격자는 **악의적인 코드**나 **입력값**을 서버로 전달하고, 서버는 이를 실행하거나 처리함으로써 보안 취약점을 악용
- 웹 애플리케이션에 대한 공격 코드는 **HTTP 요청 메시지**의 여러 부분에 삽입될 수 있다.
    - 쿼리 스트링 (Query String) / URL 파라미터
        - URL에 직접 포함된 **쿼리 스트링**에 악성 코드를 삽입
            - `https://example.com/item?id=<script>alert('XSS')</script>`
            - `https://example.com/page?name=admin'--`
            - **XSS**: 웹 애플리케이션이 쿼리 파라미터를 그대로 출력할 경우, 악성 자바스크립트가 실행
            - **SQL 인젝션**: 쿼리 파라미터를 통해 SQL 명령을 삽입하여 인증을 우회하거나, 데이터베이스에서 정보를 탈취
    - 헤더
        - 헤더에 악성 코드를 삽입
        - **User-Agent**, **Referer**, **X-Forwarded-For** 등의 헤더가 주로 공격에 사용
            - `User-Agent: <script>alert('XSS')</script>`
            - `X-Forwarded-For: 127.0.0.1; DROP TABLE users; --`
            - Referer: http://evil.com/script.js
            - **XSS**: HTTP 헤더를 통해 삽입된 악성 스크립트가 서버에서 출력될 때 실행
            - **HTTP 헤더 인젝션**: 공격자가 헤더를 조작하여 서버 응답에서 악성 코드가 실행되거나, 리다이렉션을 통해 사용자를 악성 사이트로 유도
            - **리다이렉트**: 악성 웹사이트로 리다이렉트시켜 사용자를 유도하거나 악성 코드에 노출되도록 한다.
    - 폼 데이터
        - 웹 애플리케이션에서 사용자 입력을 받는 **폼 데이터**(GET 또는 POST 방식으로 전송된 데이터)에 공격 코드를 삽입
            - `username=<script>alert('XSS')</script>`
            - `password=12345' OR '1'='1`
            - **SQL 인젝션**: 로그인 폼에서 사용자 이름이나 비밀번호 입력란에 악의적인 SQL 쿼리(예: `OR '1'='1` 등)를 삽입하여 인증을 우회
    - 쿠키
        - HTTP 요청에 포함된 **쿠키**에 악성 데이터를 삽입
            - document.cookie = "user=<script>alert('XSS')</script>”
            - **XSS**: 악성 스크립트를 쿠키에 삽입하여 사용자의 세션을 탈취하거나, 서버에 의해 쿠키 값이 반환될 때 공격이 실행될 수 있다.
            - **세션 하이재킹**: 세션 ID를 포함한 쿠키를 탈취하거나 조작하여 사용자의 인증 세션을 도용할 수 있다.
    - 파일 업로드
        - 웹 애플리케이션에서 파일 업로드를 받을 때, 업로드된 파일의 내용이나 이름에 악성 코드를 삽입
            - `.php`나 `.exe` 파일을 업로드하여 서버에서 실행되도록 할 수 있다.
            - **원격 코드 실행**: 서버에서 악성 PHP 코드나 웹 셸을 업로드하고 실행시켜 서버를 완전히 제어
            - **파일 시스템 접근**: 악성 파일을 이용해 시스템 파일을 읽거나 수정
    - URL
        - HTTP 요청의 **URL**에 포함된 파라미터(쿼리 문자열)에 공격 코드를 삽입
        - URL에서 `?` 뒤에 오는 파라미터들이 공격의 대상이 된다.
        - **XSS (Cross-Site Scripting)**: `<script>alert('XSS')</script>`와 같은 자바스크립트 코드를 삽입하여 웹 페이지에서 실행되게 만든다.
        - **SQL 인젝션**: `OR 1=1 --`와 같은 SQL 코드로 데이터베이스 쿼리를 조작하여 인증 우회나 데이터 유출을 시도할 수 있다.
- 이를 방어하기 위해서는 **입력값 검증**, **출력 시 이스케이프 처리**, **보안 헤더 적용**, **세션 관리 강화** 등의 보안 조치를 취한다.

### 웹 애플리케이션에 대한 공격 패턴
**능동적 공격(active attack)**
- 공격자가 **적극적으로** 웹 애플리케이션의 취약점을 이용하여 시스템을 공격하는 방식
- 공격자가 **사용자와 애플리케이션 간의 통신을 조작하거나 악의적인 코드를 삽입**하는 공격 행태를 보인다.
- SQL 인젝션 (SQL Injection)
    - 공격자가 **SQL 쿼리** 내에 악성 코드를 삽입하여 웹 애플리케이션의 **데이터베이스**를 조작하는 공격
    - 일반적으로 애플리케이션이 **사용자 입력을 검증하지 않거나 제대로 처리하지 않는 경우** 발생
    - 공격자는 **데이터 조회**, **수정**, **삭제**, **인증 우회** 등 다양한 악의적인 목적을 달성할 수 있다.
    - 기본적인 SQL 인젝션 공격 예시 - 1 로그인 쿼리  
    ```
    SELECT * FROM users WHERE username = '입력된_사용자' AND password = '입력된_비밀번호';

    사용자가 username과 password에 값을 입력하면, 
    서버는 이를 SQL 쿼리로 변환하여 데이터베이스에 실행하게 된다. 
    이때, 입력값을 제대로 검증하지 않는다면 공격자는 SQL 인젝션을 통해 다음과 같은 악성 입력을 전달한다.

    username = 'admin' -- 
    password = 'password'

    위와 같이 입력하면 쿼리가 다음과 같이 변형된다.

    SELECT * FROM users WHERE username = 'admin' --' AND password = 'password';

    여기서 --는 SQL에서 주석을 의미한다. 
    그래서 password = 'password' 부분은 무시되고, 쿼리는 단순히 username = 'admin'만 확인하게 되므로, 
    이는 사용자 인증을 우회하게 되어 공격자가 관리자 계정에 접근할 수 있다.
    ```
    - 기본적인 SQL 인젝션 공격 예시 - 2 OR 1=1
    - **논리 연산자**를 이용한 공격 방법
    - `OR 1=1`은 SQL 쿼리에서 **조건을 참**으로 만드는 방법
    - **OR** 연산자는 두 조건 중 하나라도 참이면 쿼리가 참으로 평가되도록 한다. 그래서 `1=1`은 **항상 참**이기 때문에, `OR 1=1`이 포함된 조건은 **언제나 참이 된다.**
    - 공격자는 **쿼리 조건을 항상 참으로 만들어** 쿼리 결과를 변경하거나 인증을 우회할 수 있다.
    ```
    SELECT * FROM products WHERE product_id = '입력된_상품_ID';


    product_id = '1' OR 1=1

    SELECT * FROM products WHERE product_id = '1' OR 1=1;


    OR 1=1은 항상 참이기 때문에, product_id = '1'에 관계없이 모든 제품을 반환하게 된다.
    결과적으로, 모든 제품이 리스트로 출력되며, 공격자는 데이터베이스에 저장된 모든 정보를 탈취한다.
    ```
- **OS 커맨드 인젝션 (OS Command Injection)**
    - 공격자가 **웹 애플리케이션을 통해 운영 체제(OS) 명령을 실행**할 수 있는 취약점을 악용하는 공격 기법
    - 웹 애플리케이션이 **사용자 입력을 적절히 검증하지 않거나, 입력값을 그대로 운영 체제 명령어에 전달**할 때 발생

**수동적 공격(passive attack)**- 공격자가 **대상 시스템에 대한 비침해적 접근**을 시도하는 공격 유형
- 공격자는 **시스템에 직접적인 손상을 주거나 변경하지 않고**, 대신 데이터를 **가로채거나, 모니터링하고, 분석**하는 방식으로 정보를 얻는다.
- **크로스 사이트 스크립팅(XSS, cross-site scripting)**
- **크로스 사이트 리퀘스트 포저리(CSRF, Crpss Site Request Forgery)**
    - CSRF 공격은 사용자가 이미 로그인된 웹사이트에 대해 악의적인 웹사이트가 사용자의 권한으로 요청을 보내는 공격
    - 공격 예시
    ```
    // 정상적인 은행 이체 양식
    <form method="post" action="/transfer">
    <input type="text" name="amount"/>
    <input type="text" name="routingNumber"/>
    <input type="text" name="account"/>
    <input type="submit" value="Transfer"/>
    </form>

    // 요청 이후
    POST /transfer HTTP/1.1
    Host: bank.example.com
    Cookie: JSESSIONID=randomid
    Content-Type: application/x-www-form-urlencoded

    amount=100.00&routingNumber=1234&account=9876

    // 악의적인 웹사이트의 양식
    <form method="post" action="https://bank.example.com/transfer">
    <input type="hidden" name="amount" value="100.00"/>
    <input type="hidden" name="routingNumber" value="evilsRoutingNumber"/>
    <input type="hidden" name="account" value="evilsAccountNumber"/>
    <input type="submit" value="Win Money!"/>
    </form>

    // 사용자가 은행 웹사이트에서 인증을 받은 후, 로그아웃하지 않고 악의적인 웹사이트를 방문했다고 가정
    // 사용자가 악의적인 웹사이트에서 "Win Money!" 버튼을 클릭하면, 의도치 않게 $100이 악의적인 사용자에게 이체

    ```
    - 보호 방법
      - 동기화 토큰 패턴 (Synchronizer Token Pattern)
        ```
        <form method="post" action="/transfer">
            <input type="hidden" name="_csrf" value="CSRF_TOKEN_HERE" />
            <!-- 다른 폼 필드들 -->
        </form>

        // Same-Origin Policy (SOP) 때문에 
        // 서버에서 발급한 CSRF 토큰은 보통 다른 도메인에서는 접근할 수 없다.

        // JavaScript를 사용해 서버가 발급한 CSRF 토큰을 얻을 수 있는 경우
        // HTTPOnly 속성을 설정하여 JavaScript에서 접근할 수 없게 한다.
        ```
        - CSRF 보호를 위한 주요 방법으로, 서버는 각 요청에 대해 세션 쿠키 외에 고유한 CSRF 토큰을 요구
        - 사용자가 요청을 보낼 때 이 토큰을 포함시켜야 하며, 서버는 요청에 포함된 토큰과 서버에서 예상한 토큰을 비교하여 일치하지 않으면 요청을 거부
    - SameSite 속성
    ```
        Set-Cookie: JSESSIONID=randomid; SameSite=Lax; Secure; HttpOnly;
    ```
    - 쿠키에 `SameSite` 속성을 설정하여 외부 사이트에서 오는 요청에서쿠키가 포함되지 않도록 할 수 있다.
    - `SameSite`의 값은 `Strict`, `Lax`, `None`이 있으며, `Strict`는외부 사이트에서 요청이 있을 경우 쿠키를 보내지 않는다.
    - **Spring Security**는 **세션 쿠키**를 직접 생성하지 않으므로SameSite 속성에 대한 직접적인 지원을 제공하지 않는다.
    - **WebFlux** 기반 애플리케이션에서 SameSite 속성에 대한 **기본적인지원**을 제공한다.
    - 로그인/로그아웃 보호
        - **로그인/로그아웃 요청**도 CSRF 공격의 대상이 될 수 있다.
        - 이를 방지하기 위해 로그인/로그아웃 요청도 **CSRF 토큰을 포함**시키는 방식으로 보호
- **DNS 스니핑 (DNS Sniffing)**
    - DNS 요청을 모니터링하여 사용자가 방문하는 **웹사이트의 URL**을 추적하는 방식
    - 공격자는 사용자가 어떤 사이트에 방문했는지 추적하고 **개인 정보를 수집**
- **네트워크 패킷 스니핑 (Packet Sniffing)**
    - **네트워크 트래픽**을 가로채어 **패킷**을 분석하는 공격 방법
    - 공격자는 네트워크 상의 데이터를 **몰래 캡처**하고, 이를 **분석**하여 **민감한 정보**를 추출
    - ex **암호화되지 않은 HTTP 트래픽**, **비밀번호**, **쿠키 정보** 등을 수집할 수 있다.

## 11.2 출력 값의 이스케이프 미비로 인한 취약성
- 클라이언트에서 체크
    - 일반적으로 JS를 사용, 때문에 변조나 무효화될 가능성이 있어서 보안 대책으로 적합하지 않다.
    - 사용자 입력 값이 시스템 요건에 적합한지에 대한 정도 검증이 적절하다.
- 웹 애플리케이션(서버 측)에서 체크
    - 입력값 체크
    - 출력값 체크

### 크로스 사이트 스크립팅(XSS, cross-site scripting)
- 웹 애플리케이션에서 사용자 입력값을 제대로 처리하지 않고 **웹 페이지에 삽입**할 수 있는 보안 취약점
- 공격자는 악의적인 **JavaScript 코드**를 웹 페이지에 삽입하여 다른 사용자의 브라우저에서 이를 실행하게 만든다.
- 사용자의 **세션 탈취**, **정보 유출**, **악성 코드 실행** 등 여러 가지 목적 수단으로 사용
- XSS의 종류
    - **반사형 XSS (Reflected XSS)**
        - 사용자가 악성 스크립트가 포함된 URL을 클릭하거나 요청을 보낼 때, 서버가 그 요청에 대한 응답을 바로 사용자에게 반환하면서 스크립트가 실행되는 방식
        - 공격자가 `http://example.com/search?query=<script>alert('XSS');</script>`와 같은 URL을 만들고, 피해자가 해당 링크를 클릭하면 브라우저에서 `alert('XSS')`라는 메시지가 표시 처리, 이는 사용자의 브라우저에서 악성 스크립트가 실행된 예시
    - **저장형 XSS (Stored XSS)**
        - 서버에 악성 스크립트가 저장되어, 나중에 다른 사용자가 해당 페이지를 요청할 때마다 스크립트가 실행
        - 악성 사용자가 댓글 입력란에 `<script>alert('XSS');</script>`와 같은 코드를 입력 후에, 서버는 이를 필터링하지 않고 그대로 저장하고, 나중에 다른 사용자가 그 페이지를 열면 악성 스크립트가 실행
    - **DOM 기반 XSS (DOM-based XSS)**
        - 클라이언트 측에서 JavaScript가 직접적으로 악성 스크립트를 실행하는 형태
        - 서버에서 데이터가 변형되지는 않지만, 클라이언트 측에서 DOM을 조작할 때 발생
        - `http://example.com?name=<script>alert('XSS');</script>`로 접속한 경우, JavaScript 코드가 이 파라미터를 처리할 때 악성 스크립트를 실행
- XSS 공격 방어 방법
    - 입력 값 검증 및 필터링
        - 사용자가 입력하는 데이터에 대해 HTML 태그나 JavaScript 코드를 필터링 처리
            - `<`, `>`, `"`, `'` 등의 특수 문자를 HTML 엔티티로 변환하이재킹
    - 출력 시 이스케이프(Escape)
        - 웹 페이지에 사용자 데이터를 출력할 때, 해당 데이터를 HTML, JavaScript, CSS 등의 컨텍스트에 맞게 이스케이프하여 실행되지 않도록 처리
    - 콘텐츠 보안 정책(CSP, Content Security Policy)
        - 웹 서버에서 CSP 헤더를 설정하여, 신뢰할 수 없는 출처의 스크립트가 실행되지 않도록 제한하기
    - HTTPOnly 및 Secure 쿠키 설정
        - 쿠키에 `HTTPOnly`와 `Secure` 속성을 설정하여 JavaScript에서 쿠키를 접근할 수 없게 하여 세션 하이재킹을 방지

### 메일 헤더 인젝션
- 이메일 전송 시스템의 취약점을 이용하여 악의적인 사용자가 이메일 헤더를 조작하는 공격 기법
- 이 공격은 이메일 헤더에 악성 코드를 삽입하거나, 의도하지 않은 이메일을 전송하게 할 수 있다.
- 예시
    - 이메일 시스템에서 사용자 A가 이메일을 보내려고 할 때, 수신자 이메일 주소에 `victim@example.com`을 입력했다고 가정
    - 이메일 시스템이 제대로 필터링하지 않는다면, 공격자는 **수신자(To)** 필드에 줄바꿈 문자(`\r\n`)를 삽입
    - [victim@example.com](mailto:victim@example.com)\r\nattacker@example.com
    - 이렇게 되면 **수신자 목록에 두 명**이 추가

### 디렉토리 접근 공격(Directory Traversal Attack)
- 공격자가 웹 애플리케이션에서 허용되지 않은 디렉토리나 파일에 접근하는 보안 취약점을 악용하는 공격 기법
- 사용자가 이미지 파일이나 문서 파일을 웹 서버에서 열 수 있도록 경로를 제공한다고 할 때, 디렉토리 접근 공격은 공격자가 이 경로를 조작하여 웹 서버의 다른 디렉토리나 파일을 불법적으로 접근하게 만드는 공격
- 예시
    - 사용자가 요청: /images/logo.png
    서버는 /var/www/html/images/logo.png 파일을 찾아서 보냄
    - 웹 애플리케이션이 파일을 요청받을 때, **사용자가 직접 경로를 입력**할 수 있게 되어 있다면, 공격자는 **"상위 디렉토리"로 이동**하는 명령을 입력하여 서버의 중요한 파일을 볼 수 있다.
    - ../../../../etc/passwd
    - 이렇게 되면, **서버가** `/etc/passwd`라는 중요한 시스템 파일을 읽고 반환할 수 있다.

### 리모트 파일 인클루션
- 공격자가 웹 서버에서 **원하지 않는 원격 파일을 포함**시킬 수 있도록 만드는 취약점
- **PHP**와 같은 서버 사이드 언어에서 파일을 포함시키는 기능을 사용할 때 발생
- 공격 방식
    - 공격자는 원격 서버에서 악성 PHP 스크립트를 포함시키고 이를 서버에서 실행하게 만든다. 이렇게 되면 공격자는 서버에서 악성 코드를 실행할 수 있게 되며, **서버를 장악**하거나 민감한 데이터를 탈취할 수 있다.
    - 공격자는 서버에서 중요한 시스템 파일이나 비밀번호 파일을 원격 서버로 전송하도록 할 수 있다.

## 11.3 웹 서버의 설정이나 설계 미비로 인한 취약성
- 웹 서버를 잘못 설정, 설계할 때 생긴 문제 등에 의해 발생하는 취약성

### 강제 브라우징(Forced Browsing)
- 웹 애플리케이션에서 사용자가 일반적으로 접근하지 못하는 페이지나 파일을 URL을 통해 직접 접근하도록 유도하는 기법
- 공격자는 웹 애플리케이션의 보안 취약점을 악용하여 보호되지 않은 자원에 접근할 수 있다.
- **URL 직접 입력**: 사용자가 웹사이트의 링크를 통해 접근할 수 없는 특정 파일이나 디렉토리로 바로 접근하는 방법
- **비공개 파일 노출**: 서버에 존재하는 로그 파일, 백업 파일, 관리 페이지 등을 사용자가 URL을 통해 직접 확인
- **경로 탐색**: 웹 애플리케이션 내의 경로 구조를 이용해 숨겨진 자원에 접근하는 기법

### 에러 처리 취약점(Error Handling Vulnerability)
- 웹 애플리케이션이 에러를 처리하는 방식에 보안 취약점이 존재할 때 발생
- 공격자는 에러 메시지나 오류 처리 방식을 이용해 애플리케이션 내부의 민감한 정보를 추출하거나 시스템의 구조를 파악
- 이러한 취약점은 종종 시스템의 오류 메시지가 과도하게 상세하거나 예상치 못한 방식으로 노출될 때 발생

### 오픈 리다이렉트(Open Redirect)
- 악의적인 사용자가 정상적인 사이트의 URL을 악용해 사용자를 다른 사이트로 리다이렉트할 수 있게 만드는 문제
- 피싱, 스팸 또는 악성 사이트로 유도

## 11.4 세션 관리 미비로 인한 취약성
### 세션 하이잭(Session Hijack)
- 공격자가 사용자의 세션을 탈취하여 그 사용자인 척 행동하거나 해당 사용자의 권한을 불법적으로 이용하는 보안 공격
- 세션 하이재킹이 발생하는 과정
    - **세션 생성**: 사용자가 웹사이트에 로그인하면 서버는 세션 ID(Session ID)를 생성하여 이를 클라이언트(사용자의 브라우저)에 전달
    - **세션 하이재킹**: 공격자는 다양한 방법을 사용하여 세션 ID를 탈취
    - 탈취된 세션 ID를 이용해 공격자는 해당 사용자의 세션을 가로채고, 로그인된 상태로 시스템에 접근할 수 있다.
    - 공격 방법
        - **네트워크 스니핑**: 공격자가 네트워크 상에서 사용자와 서버 간에 주고받는 세션 ID를 가로채는 방법. 예를 들어, HTTPS가 아닌 HTTP를 사용하면 세션 ID가 평문으로 전송되어 쉽게 탈취될 수 있다.
        - **크로스사이트 스크립팅(XSS)**: 악성 스크립트를 삽입하여 사용자의 브라우저에서 세션 ID를 추출하는 방법.
        - **세션 고정 공격(Session Fixation)**: 공격자가 미리 특정 세션 ID를 사용하여 사용자가 해당 세션 ID를 사용하도록 유도한 후, 해당 세션 ID를 탈취하는 방법.

### 세션 픽세이션(Session Fixation)
- 공격자가 특정 세션 ID를 피해자에게 할당하고, 피해자가 해당 세션 ID를 사용해 로그인하도록 유도한 후, 공격자가 그 세션을 탈취하는 보안 공격

### 세션 어댑션(Session Adoption)
- 공격자가 피해자의 세션을 훔친 후 이를 자신의 세션처럼 사용하거나, 다른 사용자의 세션을 가로채고 이를 자신의 세션으로 "적합하게(adopt)" 하는 공격 기법

## 11.5 기타
### 패스워드 크래킹(Password Cracking)
- 암호화된 비밀번호나 패스워드를 해독하여 원래의 비밀번호를 찾는 과정
- 다양한 공격 방법을 사용하여 암호화된 비밀번호를 추측하거나 역추적하는 방식으로 이루어진다.

**브루트포스 공격(Brute Force Attack)**
- 가능한 모든 조합의 문자나 숫자를 하나하나 시도하여 비밀번호를 찾는 방법
- 비밀번호 길이가 길거나 복잡하면 시간이 매우 오래 걸리고, 계산 자원이 많이 소모된다.

**사전 공격(Dictionary Attack)**
- 미리 준비된 단어 목록(사전)을 사용해 비밀번호를 추측하는 방식
- 일반적으로 사용되는 단어나 문구, 그리고 그 변형을 조합하여 시도

**레인보우 테이블 공격(Rainbow Table Attack)**
- 미리 계산된 해시 값을 이용해 비밀번호를 찾는 방법
- 해시 함수는 일방향 함수이기 때문에 원래의 값을 알아내기 어려운 방식이지만, 해시 값을 미리 계산해 놓은 테이블을 사용하면 빠르게 복호화할 수 있다.
- 레인보우 테이블을 생성하는 데 많은 저장 공간과 시간이 필요하며, 만약 사용된 해시 값에 추가적인 솔팅(salt) 처리가 되어 있으면 효과가 줄어든다.

### 클릭 재킹(Clickjacking)
- 사용자가 의도하지 않은 작업을 수행하도록 유도하기 위해, 투명한 레이어나 숨겨진 프레임을 사용하여 악성 클릭을 유도하는 공격 기법

### Dos 공격
- 시스템, 서비스, 또는 네트워크 자원을 고의적으로 방해하여 정상적인 사용자가 해당 시스템을 이용하지 못하게 만드는 공격

### DDoS 공격
- **분산 서비스 거부 공격**으로, 여러 시스템에서 동시에 대량의 트래픽을 보내거나 시스템 자원을 고갈시키는 공격

### 백도어
- 시스템이나 애플리케이션에 의도적으로 숨겨진 접근 경로를 만들어 공격자가 해당 시스템에 비밀리에 접근하거나 제어할 수 있도록 하는 공격