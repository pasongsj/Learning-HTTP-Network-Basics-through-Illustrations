# 제7장 웹을 안전하게 지켜주는 HTTPS

## 7.1 HTTP의 약점
- 평문 통신이기 때문에 도청이 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 와넌성을 증명할 수 없기 때문에 변조 가능

### 7.1.1 평문이기 때문에 도청 가능
- HTTP는 암호화 기능이 없어, 통신상 암호화 처리를 할 수 없다.
- 요청과 응답 사이의 중간에서 공격이 가능
  - 예를 들어, Wi-Fi 네트워크나 공공 인터넷에서 연결할 경우, 공격자가 네트워크 트래픽을 가로채어 패스워드나 개인 정보 같은 민감한 정보를 쉽게 훔쳐볼 수 있다.

**패킷 캡처 도구나 스니퍼 도구**
- 네트워크에서 전송되는 데이터 패킷을 가로채고 분석하는 데 사용되는 소프트웨어나 하드웨어

**도청 방지 방법**
- **암호화**
  - 통신 암호화
    - SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)
      - 두 프로토콜은 주로 웹 브라우저와 서버 간의 통신을 보호하는 데 사용
      - HTTP의 보안 버전인 HTTPS에서 핵심적인 역할
      - SSL은 TLS의 구 버전이었으며, 보안상의 취약점 때문에 TLS로 대체
      - SSL or TLS 을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP over SSL/TLS이라고 부른다.

    **SSL (Secure Sockets Layer)**
   - 보안 소켓 계층을 의미하며, 1990년대 중반에 넷스케이프(Netscape)에서 개발
    - 초기 인터넷 보안 문제를 해결하기 위해 설계된 프로토콜
    - 데이터 전송 중 도청, 변조, 위조를 방지하고, 통신 양측이 신뢰할 수 있는지 확인하는 기능을 제공
    - 데이터 전송 전에 암호화하여 중간에서 패킷을 가로채더라도, 내용을 해석할 수 없도록 한다.
    - 서버가 인증서를 사용하여 자신의 신뢰성을 증명할 수 있도록 한다.
    - 데이터가 전송되는 도중 변조되지 않도록 무결성 검증 기능을 제공한다.

    **TLS (Transport Layer Security)**
    - SSL의 후속 프로토콜로, SSL의 보안 취약점을 해결하고 개선한 버전
    - 1999년에 TLS 1.0이 처음 발표되었으며, 이후 TLS 1.1, 1.2, 1.3 버전이 출시
    - 현재는 TLS 1.2와 1.3이 대부분의 시스템에서 사용되고 있다.
    - SSL에 비해 더 안전한 암호화 알고리즘과 더 높은 보안 수준을 제공
    - 핸드쉐이크 과정에서 더 강력한 인증 절차를 거치며, 데이터 무결성 및 기밀성을 보장
    - TLS 1.3은 성능을 개선하여 더 빠르고 효율적인 통신을 제공
    - 대부분의 경우, TLS 1.2는 SSL 및 이전 TLS 버전과 호환

    **SSL/TLS 암호화의 동작 과정**
    - SSL과 TLS는 동일한 방식으로 동작하며, 주로 세션 암호화를 설정하기 위해 핸드쉐이크(Handshake) 과정을 거친다.

  - 콘텐츠 암호화
    - 통신하고 있는 콘텐츠의 내용 자체를 암호화해 버리는 방법

### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능
- 요청이나 응답에서 통신 상대를 확인하지 않아 위장이 가능하다.
- HTTPS인 SSL로 상대를 확인할 수 있는 수단으로 증명서를 제공하고 있다.

**상대를 확인하는 증명서**
- 신뢰할 수 있는 제3자 기관에 의해 발생되는 것
- 서버나 클라이언트가 실재하는 사실을 증명할 수 있다.
- 증명서 위조는 기술적으로 어렵다.
- 증명서를 통해 인증에 사용할 수 있다.

### 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능
* HTTP는 정보의 정확성을 증명할 수 없다.

**수신한 내용이 다를지도 모른다**
- 요청이나 응답이 발신된 후, 상대가 수신할 때까지 데이터가 변조되었는지 알 수 없다.
  - 중간에 콘텐츠를 가로채서 변조하는 공격을 중간자 공격(Main-in-the-Middle)라고 한다.

**변조를 방지하려면**
- MD5나 SHA-1 등의 해시 값을 확인하는 방법
- 파일의 디지털 서명을 확인하는 방법

## 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

### 7.2.1 HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS
**HTTP 통신은 암호화되지 않은 평문으로 통신된다.**
- 통신 도청 가능성
- 서버나 클라이언트를 인증하는 수단이 없다.
- 수신된 콘텐츠 변조 가능성
- HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)
- HTTPS 사용 예시
  - 웹페이지의 로그인이나 쇼핑의 결제
- HTTPS URI
  - https://www.naver.com
- 유효한 웹 사이트에 접근 시
  - 자물쇠 마크가 표시된다.

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP
- HTTP 통신 소켓 부분을 SSL or TLS 프로토콜로 대체
- 이전에는 TCP와 통신하였고, 이후에는 HTTP는 SSL과 그리고 SSL은 TCP와 통신
- SSL/TLS 사용 시 HTTP는 암호화, 증명서, 완전성 보호가 가능
- SSL/TLS는 독립된 프로토콜

### **7.2.3 상호간에 키를 교환하는 공개키 암호화 방식**
- **SSL/TLS는 공개키 암호화 방식을 채택**

**대칭키**
- 암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키 암호라고 부른다.
- 암호화나 복호화할 때 같은 키를 사용하기 때문에 외부에 키를 공유해서는 안된다.

**공개키** 
- 대칭 키를 보완한 암호화 방식
- 서로 다른 두 개의 키인 개인키와 공개키를 사용한다.
- 중간 네트워크에서 개입자는 공개키를 가로채더라도 복호화가 불가능
- 기존 대칭키 전략의 도청, 변조를 방지할 수 있다.
1. B는 공개키/개인키 쌍을 생성한다.
2. A는 B의 공개키로 전송 데이터를 암호화 후에 B에게 전송한다.
3. B는 이를 자신의 개인키로 복호화한다.

**HTTPS는 하이브리드 암호 시스템**
- HTTP는 대칭, 비대칭 양쪽 성질을 가진 하이브리드 암호 시스템
- 키 교환 시 공개키 암호 사용, 메시지 교환 시 대칭키 암호 사용

### 7.2.4 공개키가 정확한지 아닌지를 증명하는 증명서
- 공개키 위조 여부를 증명할 수 없기 때문에, 인증 기관이 공개키 증명서 제공을 통해 이를 해결
- 인증기관(CA)은 클라이언트와 서버가 모두 신뢰하는 제3자 기관
    - HTTPS를 적용하려면 신뢰할 수 있는 CA(인증 기관)로부터 인증서를 구입해야 한다.
    - 이 인증서를 구입하면, CA 기업은 자신의 개인 키로 암호화한 인증서를 발급해 준다.
    - 유명 인증 기관에 VeriSign 사가 있다.
    - 한국전자 인증기관에는 digicert를 이용한다.

**조직의 실제성을 증명하는 EV SSL 증명서**
- EV SSL 인증서는 웹브라우저와 웹서버간의 암호화 통신 시, 사용자에게 서버의 안전성과 신뢰성을 전달하기 위하여 브라우저 주소 창을 녹색으로 변화시키며, 심사과정이 더욱 강화된 SSL인증서
- 실존하는 기업인지 확인하는 증명서
- 세계 표준의 인정 가이드라인에 의해서 발행되는 증명서
- 브라우저 주소창의 색이 녹색으로 변하면 EV SSL 증명서로 증명된 웹사이트
- 주소창 옆에는 SSL 증명서에 기재된 조직명 및 증명서를 발행한 인증 기관 명이 표시
- 피싱 사기 방지를 의도한 것

**클라이언트를 확인하는 클라이언트 증명서**
- 특정 사용자가 맞는지 확인하는 디지털 신분증
- 클라이언트인 것을 증명할 수 있는 클라이언트 인증서
- 증명서 입수 과정에서 클라이언트 증명성를 설치할 필요성
- 증명서는 유로이기 때문에 유저 수만큼 비용과 인스톨 작업을 해야 한다.
- 때문에 특정 용도로만 사용된다.
- 예를 들어 인터넷 뱅킹에서 로그인할 때 인증 이후에 특정 단말기에서 접근하는지 확인 가능
- 대중교통 스마트 카드도 일종의 "인증서" 역할
- 유럽이나 다른 나라들에서는 정부가 발급한 신분증에 클라이언트 인증서를 넣어서, 온라인 서비스나 세금 납부 등에서 사용자가 안전하게 인증할 수 있도록 한다.
- 인증서는 클라이언트 실재를 증명할 뿐, 사용자 존재 유무를 증명하진 못한다.

### 7.2.5 안전한 통신을 하는 HTTPS의 구조

**SSL**
웹 브라우저와 서버 간에 전송되는 데이터를 보호하는 보안 프로토콜입니다. SSL은 데이터 암호화를 통해 양방향 통신에서 데이터를 보호하며, 이를 통해 해커가 통신을 가로채지 못하도록 한다.

암호화된 데이터를 전송하기 위해 공개키와 대칭키 혼합해서 사용

**SSL Handshake**
Handshake는 악수를 의미하는데, 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름이다.

클라이언트와 서버가 데이터를 교환하기 전에 보안 연결을 설정하는 과정
이 과정에서 양측은 암호화 방법을 합의하고, 신원을 확인하며, 안전한 통신을 위한 키를 생성

SSL/TLS 핸드쉐이크는 클라이언트와 서버가 안전한 연결을 설정하기 위한 과정
양측은 안전하게 데이터를 주고받을 수 있는 암호화된 연결을 생성
핸드쉐이크 과정은 클라이언트-헬로, 서버-헬로, 인증, 세션 키 생성 등을 포함하여 보안 통신을 위한 기반을 마련

![Image](https://github.com/user-attachments/assets/dee3305f-a964-4d5e-88d8-b336a81190be)  


**협상 과정(네고시에이션)**  

**Cipher Suite**  
SSL 프로토콜 버전, 인증서 검정, 데이터 암호화 프로토콜, Hash 방식 등의 정보를 담고 있는 존재로, 선택된 Cipher Suite의 알고리즘에 따라 데이터를 암호화하게 된다.

암호화 통신에서 사용하는 암호화 알고리즘의 집합
TLS/SSL 프로토콜은 이 알고리즘을 사용하여 키를 생성하고 데이터를 암호화

여러 알고리즘을 포함한다.
- **키 교환 알고리즘**: 공유 키를 생성하는 알고리즘 (예: Diffie-Hellman)
- **대칭 암호화 알고리즘**: 클라이언트와 서버 간의 데이터를 암호화 (예: AES)
- **메시지 인증 알고리즘**: 메시지의 무결성을 확인 (예: SHA-256)  
<br>

1- **ClientHello**
클라이언트가 서버에 연결을 시도하며 전송하는 패킷이다. 자신이 사용 가능한 Cipher Suite 목록, Session ID, SSL 프로토콜 버전, Random Byte 등을 전달한다.

**Random Byte**  
여기서 Random Byte는 클라이언트에서 생성한 난수이며, 이후에 대칭키를 만들 때 사용된다.

**Session ID**  
![Image](https://github.com/user-attachments/assets/b7599fb4-5c77-472a-b50e-3fdbb7be3ca4)

Session ID는 캐싱과 같다. 매번 Handshake을 하는 과정을 하지 않기 위해 최초 한 번만 Handshake 할 수 있도록 ID 값을 정해두는 것  
<br>

2 -  **ServerHello**    
Client가 보낸 암호화 방식 중에 서버가 사용 가능한 암호화 방식을 선택하여 보낸다.
서버와 클라이언트가 암호화 방식에 대해 협상을 본 것

서버는 SSL 버전과 암호 스위트를 포함한다.

**Random Byte**
서버에서 생성한 난수, 클라이언트와 동일하게 대칭키를 만들 때 사용

**Session ID** 
Client Hello에 Session ID가 0으로 왔다면 새로 Session ID를 생성한다. 그게 아니라면 그 Session ID가 유효한지 확인하고 보낸다.  
<br>

3 - **Certificate**
서버의 인증서를 클라이언트에게 보내는 단계, 인증서 내부에는 Server가 발행한 공개키가 들어있다.  

**SSL 인증서 생성**
1. 서버는 CA에 자신의 정보와 공개 키를 보낸다.
2. CA는 자신의 개인 키로 서버 정보와 서버 공개 키에 대해 암호화하여 인증서를 생성한 뒤, 인증서를 서버에게 전달한다.
3. 이후 클라이언트가 서버에 요청 시 CA 기관의 공개키를 요청하거나 저장하고 있어야 한다.

클라이언트는 이 메세지를 통해 서버의 인증서가 무결한지 검증한다.
서버가 보낸 CA (Certificate Authority, 인증 기관)의 개인 키로 암호화된 이 SSL 인증서를 이미 모두에게 공개된 CA의 공개 키를 사용하여 복호화한다. 
복호화에 성공하면 이 인증서는 CA가 서명한 것이 맞으니 진짜임을 검증할 수 있다.  
<br>

4 - **Server Key Exchange / ServerHello Done**  
서버의 공개 키가 SSL 인증서 내부에 없는 경우, 서버가 직접 전달한다.  그게 아니고, 공개 키가 SSL 인증서 내부에 있을 경우 Server Key Exchange는 생략된다. 

서버가 행동을 마쳤음을 전달한다.
클라이언트가 CA의 공개 키를 통해 인증서를 복호화 한 후 서버의 공개 키를 확보할 수 있다.  
<br>

**협상 과정(네고시에이션) 이후**  

**클라이언트 대칭키 생성**
메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있다.

여기서 전달된 대칭 키가 SSL Handshake의 목적이자 가장 중요한 수단인 데이터를 실제로 암호화할 대칭 키다.

이전에 주고 받았던 클라이언트의 난수와 서버의 난수를 조합하여 pre master secret 이라는 대칭키를 생성한다.  
이제 이 pre master secret(대칭키)를 서버의 공개키로 암호화 한다.  
<br>

1 - **Client Key Exchange** (SSL Handshake 종료)
클라이언트는 데이터 암호화에 사용할 대칭키를 생성한 후 SSL 인증서 내부에서 추출한 서버의 공개 키를 이용해 암호화한 후 서버에게 전달한다.

이렇게 얻은 대칭 키를 활용하여 서로가 서로의 데이터를 안전하게 복호화 하면서 통신할 수 있다.  
<br>

2 - **ChangeCipherSpec / Finished**
ChangeCipherSpec 패킷은 클라이언트와 서버 모두가 서로에게 보내는 패킷으로, 교환할 정보를 모두 교환한 뒤 통신할 준비가 다 되었음을 알리는 패킷이다.

그리고 Finished 패킷을 보내어 SSL Handshake를 종료하게 된다.

양측이 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립
SSL에 의해서 통신이 보호된다. 

이후 애플리케이션 계층의 프로토콜에 의해 통신이 진행되며, HTTP 요청과 응답에서 진행된다.  
<br>

3 - **close_notify / TCP FIN**  
마지막 통신 이후 클라이언트가 접속을 끊기 위해 close_notify 메시지를 송신한다.

그리고 TCP FIN 메시지를 보내 TCP 통신을 종료한다.

**SSL과 TLS**
- 넷스케이프 커뮤니케이션스사가 내놓은 프로토콜
- SSL 3.0까지는 같은 회사에서 개발
- 현재는 IETF로 이전
- SSL 3.0 기반한 TLS 1.0이 책정되어 현재 TLS 1.1 ~ 1.3까지 존재
- TLS는 SSL을 바탕으로 한 프로토콜이지만, 총칭해서 SSL이라고 부른다.

**SSL은 느리다?**
- HTTPS는 서버, 클라이언트 모두 암호화와 복호화 처리가 필요
- CPU나 메모리 등의 하드웨어 리소스를 소비한다.
- 기존 HTTP보다 2배에서 100배 가량 느려진다.
- SSL 엑셀레이터 하드웨어를 사용해서 이 문제를 해결하기도 한다.
    - SSL을 처리하기 위한 전용 하드웨어
    - 소프트웨어로 SSL을 처리할 때보다 몇 배 빠른 계산이 가능

**왜 항상 HTTPS를 사용하지 않는가?**
- HTTPS 방식은 암호.복호화와 그만큼의 많은 리소스를 요구하기 때문에 느리다.
- 민감한 보안이 필요한 경우에 HTTPS 암호화 통신을 사용하는 것이 좋다.  

<br>

# 참고
- [**네트워크] TLS & SSL Handshake**](https://steady-coding.tistory.com/512)
- [**Network]TLS/SSL Handshake**](https://hihellosuah.tistory.com/103)
- [**TLS(SSL) - 3. Handshake**](https://babbab2.tistory.com/7)