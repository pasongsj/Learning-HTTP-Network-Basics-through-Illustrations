# 제8장 누가 액세스하고 있는지를 확인하는 검증
## 8.1 인증이란?
* 사용자가 본인임을 증명하는 과정

### 인증 방법
- 패스워드
- 원타임 토큰
  - 자신의 기기 등에 표시되는 한 번쓰고 버리는 일회성 비밀번호
- 전자 증명서
  - 본인만이 가지고 있는 정보
- 바이오 매트릭스
  - 지문이나 홍채 등 본인의 신체 정보
- IC 카드 등
  - 본인만이 가지고 있는 정보

### HTTP에서 사용하는 인증 방법
- BASIC 인증
- DIGEST 인증
- SSL, 클라이언트 인증
- 폼 베이스 인증

## 8.2 BASIC 인증
```
Authorization: Basic base64({USERNAME}:{PASSWORD})
```

- HTTP/1.0에 구현된 HTTP 인증 방식
- RFC 7617에 정의되어 있으며, 자격 증명(사용자 ID/비밀번호 쌍)을 base64로 인코딩하여 전송
- [**Base64**](https://developer.mozilla.org/en-US/docs/Glossary/Base64)로 인코딩한 “사용자ID:비밀번호” 문자열을 `Basic`과 함께 인증 헤더에 입력
- 사용자 ID와 비밀번호가 네트워크를 통해 평문으로 전달
- 사용자 많을 경우 성능에 부담을 주고, 세밀한 권한 제어가 어려워 복잡한 서비스에는 적합하지 않다.
- Basic 인증을 사용하는 요청은 꼭 HTTPS, [**SSL/TLS**](https://docs.tosspayments.com/resources/glossary/tls)로 통신해야 한다.
- 한 번 BASIC 인증할 경우 일반 브라우저에서는 로그아웃을 할 수 없다.
- 간단한 내부 시스템이나 테스트 환경에서 사용될 때 적합하다.

<br>

### BASIC 인증 수순
1. 리퀘스트 송신
2. 상태코드 401로 응답해서 인증이 필요하다는 것을 전달
   1. 상태코드 401(Authorization Required + BASIC 인증 방식 + Request-URI의 보호 공간을 식별하기 위한 문자열(realm)을 WWW-Authenticate 헤더 필드에 포함해서 응답을 반환
3. 유저ID와 패스워드를 Base64 형식으로 인코드한 값을 Authorization 헤더 필드에 포함해서 리퀘스트로 송신
    1. BASIC 인증을 위해 ID와 패스워드를 서버에 송신
    2. ID : PWD 형식을 Base64 인코드 방식으로 전송
        1. ex guest:guest → Z3Vkc3Q6Z3Vkc3Q
    3. 브라우저는 자동적으로 Base64로 인코딩 처리
4. 인증 성공 시에는 상태 코드 200으로 응답하고, 실패했을 경우에는 다시 상태 코드 401로 응답
    1. 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환  

<br>

## 8.3 DIGEST 인증
- 챌린지 리스폰스 방식을 사용
  - 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한다. 이 값을 상대에게 송신하여 인증을 하는 방법
  - 사용자 인증을 위한 보안 메커니즘
  - 서버가 클라이언트에게 도전(챌린지)을 보내고, 클라이언트가 이에 대해 응답(리스폰스)을 보내는 방식
  - 비밀번호를 직접 전송하는 대신, 암호화된 정보를 주고받아 보안을 강화
- BASIC 인증에 비해서 높은 보안 등급을 가지고 있다.
- 패스워드의 도청을 방지하기 위한 보호 기능을 제공하지만, 위장을 방지하는 기능은 제공하지 않는다.
- 사용상의 문제와 많은 웹 사이트에서 요구되는 보안 등급에는 미치지 못하기 때문에 사용되지 않는다.  

### DIGEST 인증 수순
1. 리퀘스트 송신
2. 인증이 필요하다는 것을 전달하는 상태 코드 401로 응답하는 것과 함께 패스워드와 챌린지 코드(nonce)를 송신
    1. 서버는 상태 코드 401 Authorization Required와 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환
    2. WWW-Authenticate 헤더 필드에는 “realm”, “nonce” 두 개의 정보가 포함되어야 한다.
    3. “nonce”는 401 리스폰스를 반환할 때마다 생성되는 유일한 문자열
    4. “nonce” 문자열은 Base64이거나 16진수 형식을 권장
3. 패스워드와 챌린지 코드에서 리스폰스 코드(response)를 계산해서 송신
    1. DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 포함해서 리스폰스를 반환
    2. “username”, “realm”, “nonce”, “uri”, “response” 정보가 들어가 있어야 한다.
    3. “realm”, “nonce”는 서버에서 받은 데이터를 사용한다.
4. 인증 성공 시에는 상태 코드 200으로 응답하고, 실패했을 경우에는 다시 상태 코드 401로 응답
    1. 인증 성공 시 Request-URI의 리소스를 포함한 리스폰스를 반환

## 8.4 SSL 클라이언트 인증
- HTTPS의 클라이언트 인증서를 이용한 인증 방식
- **클라이언트가 자신을 인증**하기 위해 **디지털 인증서**를 사용하는 보안 프로토콜
- 서버와 클라이언트 간의 양방향 인증을 제공

### SSL 클라이언트 인증의 인증 수순
- 사전에 클라이언트 증명성를 배포 및 인스톨을 해줘야 한다.
1. 서버는 클라이언트에게 클라이언트 증명서를 요구하는 Certificate Request 메세지를 송신
2. 사용자는 송신할 클라이언트 증명성를 선택 및 전송한다.
3. 서버는 클라이언트 증명서를 검증하여 검증 결과가 정확하다면 클라이언트 공개키를 취득한다, 그 이후에 HTTP에 의한 암호를 개시한다.

### SSL 클라이언트 인증은 2-factor 인증에서 사용된다
- SSL 클라이언트 인증은 폼 베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용된다.
  - 2-factor 인증은 다른 정보를 병용해서 인증을 하는 방법

### SSL 클라이언트 인증은 이용하는데 비용이 필요하다
- 인증 기관에서 클라이언트 증명서를 구입하는 비용이나 서버의 운영자 자신이 인증 기관을 만들어서 안전하게 운용하기 위해 들어가는 비용이 들어간다.

<br>

## 8.5 폼 베이스 인증
- 웹 애플리케이션에서 가장 일반적으로 사용되는 인증 방식
- 사용자가 웹 폼을 통해 로그인하는 방식이다. 이 방식은 사용자 이름과 비밀번호를 입력하는 HTML 폼을 제공하고, 이를 서버로 전송하여 인증을 처리
- 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보(Credential)을 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식
- 웹 애플리케이션에 따라 제공되는 인터페이스나 인증의 방법이 다양하다.  

### 세션 관리와 쿠키에 의한 구현
- 표준적 사양이 결정되지 않은 폼 베이스 인증 방식에서 일반적으로 사용되는 방법이다.
- HTTP 단점인 비상태 저장을 보완하기 위한 방식으로 세션 관리와 쿠키, 토큰이 있다.

1. 자격 정보(ID, 패스워드)를 전송
    - 인증 정보와 자격 정보를 포함해서 리퀘스트를 송신
    - 대개는 POST 메소드가 사용되어 엔티티 바디에 자격 정보를 저장
    - 송신에는 HTTPS 통신을 이용
2. 세션 ID를 쿠키로 송신
    1. 유저 식별하기 위해 세션 ID를 발행
    2. 클라이언트에서 수신한 자격 정보를 검증 및 인증
    3. 유저의 인증 상태를 세션 ID와 연관지어 서버 측에 기록
    4. 클라이언트 측에 송신할 때는 Set-Cookie 헤더 필드에 세션 ID를 저장해서 리스폰스를 반환
    5. 세션 ID는 다른 유저와 구별하기 위한 값
    6. 세션 ID 유출 시 악용이 가능하다.
    7. 크로스 사이트 스크립팅 등의 취약성을 해결하기 위해 httponly 속성을 사용
3. 쿠키로 세션 ID를 송신
    1. 서버 측에서 받은 세션 ID를 쿠키로 저장
    2. 다음번에 서버에 리퀘스트를 송신할 경우에는 브라우저가 자동으로 쿠키를 송출한다.