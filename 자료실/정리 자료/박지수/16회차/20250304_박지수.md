# 7.2 HTTPs = HTTP + 암호화 + 인증 + 완전성 보호
## 7.2.1 HTTP에 암호화와 인증과 완정성 보호를 더한 HTTPS
## 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP
## 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식
SSL은 공개키 암호화 방식을 사용함.
암호화 복호화해 같은 키를 사용하는 걸 공통키 암호라고 부릅니다.
하지만 네트워크 상에서 어떻게 안전하게 키를 넘겨줄 수 있을까?
또한 받은 키를 안전하게 보관도 해야한다.

### 공개키 암호화
2개의 키를 사용함, 하나는 비밀키, 하나는 공개키.

암호를 보내는 측이 상대의 공개키를 사용해서 암호화함. 그리고 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용하여 복호화를 실시함.
이 방식은 비밀키를 네트워크에 보내지 않아서 안전함.
그렇다고 암호문과 공개키를 가지고만 평문으로 해독하는건 수학적으로 매우 어려움. -> 그치만 할 수는 있다는 말?

그래서 키자체는 공개키 암호화로 보내고
메세지는 공통키 암호화로 주고 받는다.

## 7.2.4 공개키가 정확한지 아닌지 증명하는 증명서
수신한 공개키가 원래 의도한 서버것인지 인증하는게 필요함. 이걸 CA로 한다.

인증기관에 공개키 보내서 공개키 인증서 받음
인증기관의 공개키는 브라우저에 내장되어 있음. 
서버의 공개키 인증서를 입수해서 CA의 공개키로 검증하고 진위여부 확인.
맞다면 서버의 공개키로 암호화해서 메세지 전송(공개키 암호화)

## ssl은 느리다?
통신이 지연된다
cpu나 메모리 등을 과도하게 소비함으로서 처리가 느려진다.


---
## 질문
인증기관의 공개키 내장해놔도, 결국 볼 수 있다는거 아님?
그러면 공개키가 아닌 비밀키를 브라우저에서 들고 있어야 하는거아님?

클라이언트 - 웹서버 - WAS - DB 중에서 
웹서버 nginx, apache 등이 이 역할을 하는거?
front end는 웹서버가 정적파일을 호스팅하는 것임