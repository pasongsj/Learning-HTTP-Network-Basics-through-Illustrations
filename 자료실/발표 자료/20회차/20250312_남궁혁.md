# 제 11장 웹 공격 기술

## 11.1 웹 공격 기술
- HTTP를 사용하는 서버, 클라이언트, 웹 애플리케이션 등의 리소스를 대상으로 보안 공격을 수행한다.

### HTTP에는 보안 기능이 없다.
**문제점**
- **데이터를 평문(plain text)으로 전송**
    - 클라이언트와 서버 간에 주고받는 모든 데이터가 암호화되지 않기 때문에, 중간에서 누군가가 데이터를 가로채서 읽거나 분석할 수 있다.
        - 웹 서버와 클라이언트 간의 모든 요청과 응답을 노출시키므로, 악의적인 공격자가 통신 내용, 요청 헤더, 쿠키 등을 쉽게 확인
- **데이터 무결성 보장 X**
    - 전송된 데이터가 중간에서 변조되었는지 확인하는 메커니즘을 제공하지 않는다.
        - 중간에서 데이터를 변조할 수 있는 **Man-in-the-Middle(MITM) 공격**에 취약하기 때문에, 공격자가 사용자와 서버 사이에 끼어들어 데이터를 수정한 후 정상적인 통신인 것처럼 보이게 만들 수 있다.
- **인증 및 신뢰성 부족**
    - 서버가 누구인지, 서버가 정확히 신뢰할 수 있는 곳인지 확인하지 않는다.
        - **Phishing(피싱)** 공격에 취약하다. 공격자는 사용자에게 가짜 웹사이트를 만들고 실제 웹사이트처럼 보이게 할 수 있으며, 사용자는 이를 통해 자신의 민감한 정보를 입력할 수 있다.

**해결 방법**
- HTTP는 이러한 문제를 해결하기 위해 HTTPS(SSL/TLS) 암호화와 인증을 사용하여 웹 통신을 안전하게 보호한다.
- SSH  
![Image](https://github.com/user-attachments/assets/1e35fcdf-8aca-4c3b-9ef6-3a94918369fe)  

  - 네트워크를 통해 안전하게 원격 시스템에 접속하고 명령을 실행할 수 있도록 해주는 프로토콜로서 주로 서버 관리, 원격 로그인, 파일 전송 등에 사용
  - **암호화된 통신**을 제공하여 데이터가 전송되는 동안 보안을 보장
    - 클라이언트와 서버 간의 모든 데이터 전송을 암호화하여, 네트워크 상에서 정보가 노출되는 것을 방지한다.
    - 위에서 언급한 중간자 공격(Man-in-the-Middle)을 막을 수 있다.
  - 두 가지 주요 인증 방법을 지원
    - 사용자가 서버에 로그인할 때 **패스워드**를 ****입력하여 인증
    - 비대칭키 전략
      - 서버는 클라이언트의 공개키를 알고 있고, 클라이언트는 개인키로 인증을 수행
  - **SSL/TLS와 차이**
    - 모두 보안을 제공하는 프로토콜이지만, 각각의 목적과 사용되는 방식에서 차이가 있다.
    - **SSH (Secure Shell)**
      - SSH는 서버와 클라이언트 간의 **암호화된 원격 접속**을 위한 프로토콜
      - 주로 **원격 로그인**과 **원격 명령 실행**을 위해 사용
    - **TLS (Transport Layer Security)**
      - TLS는 네트워크 상에서 데이터가 안전하게 전송될 수 있도록 **암호화, 인증, 무결성 보장**을 제공
      - 주로 **애플리케이션 계층의 통신 보안**을 위해 사용된다. HTTPS, 이메일, VoIP 등 다양한 프로토콜에서 사용

<br>

### 리퀘스트는 클라이언트에서 변조 가능
- 웹 애플리케이션에 대한 공격은 **HTTP 요청 메시지**를 통해 이루어진다.
- 공격자는 **악의적인 코드**나 **입력값**을 서버로 전달하고, 서버는 이를 실행하거나 처리함으로써 보안 취약점을 악용
- 웹 애플리케이션에 대한 공격 코드는 **HTTP 요청 메시지**의 여러 부분에 삽입될 수 있다.
  - 쿼리 스트링 (Query String) / URL 파라미터
    - URL에 직접 포함된 **쿼리 스트링**에 악성 코드를 삽입
    ```
        `https://example.com/item?id=<script>alert('XSS')</script>`
        `https://example.com/page?name=admin'--`
    ```

    - **XSS**: 웹 애플리케이션이 쿼리 파라미터를 그대로 출력할 경우, 악 자바스크립트가 실행
    - **SQL 인젝션**: 쿼리 파라미터를 통해 SQL 명령을 삽입하여 인증 우회하거나, 데이터베이스에서 정보를 탈취
  - 헤더
    - 헤더에 악성 코드를 삽입
    - **User-Agent**, **Referer**, **X-Forwarded-For** 등의 헤더가 주로 공격에 사용
    ```
        `User-Agent: <script>alert('XSS')</script>`
        `X-Forwarded-For: 127.0.0.1; DROP TABLE users; --`
        `Referer: http://evil.comscript.js`
    ```
     
    - **XSS**: HTTP 헤더를 통해삽입된 악성 스크립트가 서버에서출력될 때 실행
    - **HTTP 헤더 인젝션**:공격자가 헤더를 조작하여 서버응답에서 악성 코드가 실행되거나, 리다이렉션을 통해사용자를 악성 사이트로 유도
    - **리다이렉트**: 악성웹사이트로 리다이렉트시켜사용자를 유도하거나 악성  코드에 노출되도록 한다.
  - 폼 데이터
    - 웹 애플리케이션에서 사용자 입력을 받는 **폼 데이터**(GET 또는 POST 방식으로 전송된 데이터)에 공격 코드를 삽입
    
      ```
          `username=<script>alert('XSS')</script>`
          `password=12345' OR '1'='1`
      ```
  
        - **SQL 인젝션**: 로그인 폼에서사용자 이름이나 비밀번호입력란에 악의적인 SQL 쿼리(예:`OR '1'='1` 등)를 삽입하여인증을 우회
  - 쿠키
      - HTTP 요청에 포함된 **쿠키**에 악성 데이터를 삽입
        ```
            document.cookie = "user=<script>alert('XSS')</script>
        ```
        
        - **XSS**: 악성 스크립트를 쿠키에 삽입하여 사용자의 세션을 탈취하거나, 서버에 의해 쿠키 값이 반환될 때 공격이 실행될 수 있다.
        - **세션 하이재킹**: 세션 ID를 포함한 쿠키를 탈취하거나 조작하여 사용자의 인증 세션을 도용할 수 있다.
  - 파일 업로드
    - 웹 애플리케이션에서 파일 업로드를 받을 때, 업로드된 파일의 내용이나 이름에 악성 코드를 삽입
      - `.php`나 `.exe` 파일을 업로드하여 서버에서 실행되도록 할 수 있다.
        - **원격 코드 실행**: 서버에서 악성 PHP 코드나 웹 셸을 업로드하고 실행시켜 서버를 완전히 제어
        - **파일 시스템 접근**: 악성 파일을 이용해 시스템 파일을 읽거나 수정
  - URL
    - HTTP 요청의 **URL**에 포함된 파라미터(쿼리 문자열)에 공격 코드를 삽입
    - URL에서 `?` 뒤에 오는 파라미터들이 공격의 대상이 된다.
    - **XSS (Cross-Site Scripting)**: `<script>alert('XSS')</script>`와 같은 자바스크립트 코드를 삽입하여 웹 페이지에서 실행되게 만든다.
    - **SQL 인젝션**: `OR 1=1 --`와 같은 SQL 코드로 데이터베이스 쿼리를 조작하여 인증 우회나 데이터 유출을 시도할 수 있다.
- 이를 방어하기 위해서는 **입력값 검증**, **출력 시 이스케이프 처리**, **보안 헤더 적용**, **세션 관리 강화** 등의 보안 조치를 취한다.

<br>

### 웹 애플리케이션에 대한 공격 패턴
**능동적 공격(active attack)**
- 공격자가 **적극적으로** 웹 애플리케이션의 취약점을 이용하여 시스템을 공격하는 방식
- 공격자가 **사용자와 애플리케이션 간의 통신을 조작하거나 악의적인 코드를 삽입**하는 공격 행태를 보인다.
- SQL 인젝션 (SQL Injection)
    - 공격자가 **SQL 쿼리** 내에 악성 코드를 삽입하여 웹 애플리케이션의 **데이터베이스**를 조작하는 공격
    - 일반적으로 애플리케이션이 **사용자 입력을 검증하지 않거나 제대로 처리하지 않는 경우** 발생
    - 공격자는 **데이터 조회**, **수정**, **삭제**, **인증 우회** 등 다양한 악의적인 목적을 달성할 수 있다.
    - 기본적인 SQL 인젝션 공격 예시 - 1 로그인 쿼리

```
SELECT * FROM users WHERE username = '입력된_사용자' AND password = '입력된_비밀번호';

<!-- 사용자가 username과 password에 값을 입력하면, 
서버는 이를 SQL 쿼리로 변환하여 데이터베이스에 실행하게 된다. 
이때, 입력값을 제대로 검증하지 않는다면 공격자는 SQL 인젝션을 통해 다음과 같은 악성 입력을 전달한다. -->

username = 'admin' -- 
password = 'password'

<!-- 위와 같이 입력하면 쿼리가 다음과 같이 변형된다. -->

SELECT * FROM users WHERE username = 'admin' --' AND password = 'password';

<!-- 여기서 --는 SQL에서 주석을 의미한다. 
그래서 password = 'password' 부분은 무시되고, 쿼리는 단순히 username = 'admin'만 확인하게 되므로, 
이는 사용자 인증을 우회하게 되어 공격자가 관리자 계정에 접근할 수 있다. -->

```

- 기본적인 SQL 인젝션 공격 예시 - 2 OR 1=1
    - **논리 연산자**를 이용한 공격 방법
    - `OR 1=1`은 SQL 쿼리에서 **조건을 참**으로 만드는 방법
    - **OR** 연산자는 두 조건 중 하나라도 참이면 쿼리가 참으로 평가되도록 한다. 그래서 `1=1`은 **항상 참**이기 때문에, `OR 1=1`이 포함된 조건은 **언제나 참이 된다.**
    - 공격자는 **쿼리 조건을 항상 참으로 만들어** 쿼리 결과를 변경하거나 인증을 우회할 수 있다.
        
```
SELECT * FROM products WHERE product_id = '입력된_상품_ID';


product_id = '1' OR 1=1

SELECT * FROM products WHERE product_id = '1' OR 1=1;


<!-- OR 1=1은 항상 참이기 때문에, product_id = '1'에 관계없이 모든 제품을 반환하게 된다.
결과적으로, 모든 제품이 리스트로 출력되며, 공격자는 데이터베이스에 저장된 모든 정보를 탈취한다. -->
```

- **OS 커맨드 인젝션 (OS Command Injection)**
    - 공격자가 **웹 애플리케이션을 통해 운영 체제(OS) 명령을 실행**할 수 있는 취약점을 악용하는 공격 기법
    - 웹 애플리케이션이 **사용자 입력을 적절히 검증하지 않거나, 입력값을 그대로 운영 체제 명령어에 전달**할 때 발생
        
<br>

**수동적 공격(passive attack)**
- 공격자가 **대상 시스템에 대한 비침해적 접근**을 시도하는 공격 유형
- 공격자는 **시스템에 직접적인 손상을 주거나 변경하지 않고**, 대신 데이터를 **가로채거나, 모니터링하고, 분석**하는 방식으로 정보를 얻는다.
- **크로스 사이트 스크립팅(XSS, cross-site scripting)**
- **크로스 사이트 리퀘스트 포저리(CSRF, Crpss Site Request Forgery)**
    - CSRF 공격은 사용자가 이미 로그인된 웹사이트에 대해 악의적인 웹사이트가 사용자의 권한으로 요청을 보내는 공격
    - 공격 예시

    ```
    // 정상적인 은행 이체 양식
    <form method="post" action="/transfer">
      <input type="text" name="amount"/>
      <input type="text" name="routingNumber"/>
      <input type="text" name="account"/>
      <input type="submit" value="Transfer"/>
    </form>
    
    // 요청 이후
    POST /transfer HTTP/1.1
    Host: bank.example.com
    Cookie: JSESSIONID=randomid
    Content-Type: application/  x-www-form-urlencoded
    
    amount=100.00&routingNumber=1234&   account=9876
    
    // 악의적인 웹사이트의 양식
    <form method="post" action="https://bank.   example.com/transfer">
      <input type="hidden" name="amount"    value="100.00"/>
      <input type="hidden" name="routingNumber"     value="evilsRoutingNumber"/>
      <input type="hidden" name="account"   value="evilsAccountNumber"/>
      <input type="submit" value="Win Money!"/>
    </form>
    
    // 사용자가 은행 웹사이트에서 인증을 받은   후, 로그아웃하지 않고 악의적인 웹사이트를     방문했다고 가정
    // 사용자가 악의적인 웹사이트에서 "Win  Money!" 버튼을 클릭하면, 의도치 않게 $100이  악의적인 사용자에게 이체
    ```

- 보호 방법
  - 동기화 토큰 패턴 (Synchronizer Token Pattern)
    ```
    <form method="post" action="/transfer">
    <input type="hidden" name="_csrf" value="CSRF_TOKEN_HERE" />
    <!-- 다른 폼 필드들 -->
    </form>

    // Same-Origin Policy (SOP) 때문에 
    // 서버에서 발급한 CSRF 토큰은 보통 다른 도메인에서는 접근할 수 없다.

    // JavaScript를 사용해 서버가 발급한 CSRF 토큰을 얻을 수 있는 경우
    // HTTPOnly 속성을 설정하여 JavaScript에서 접근할 수 없게 한다.
    ```

    - CSRF 보호를 위한 주요 방법으로, 서버는 각 요청에 대해 세션 쿠키 외에 고유한 CSRF 토큰을 요구
    - 사용자가 요청을 보낼 때 이 토큰을 포함시켜야 하며, 서버는 요청에 포함된 토큰과 서버에서 예상한 토큰을 비교하여 일치하지 않으면 요청을 거부

    - SameSite 속성
    ```
    Set-Cookie: JSESSIONID=randomid; SameSite=Lax; Secure; HttpOnly;
    ```
      - 쿠키에 `SameSite` 속성을 설정하여 외부 사이트에서 오는 요청에서 쿠키가 포함되지 않도록 할 수 있다.
      - `SameSite`의 값은 `Strict`, `Lax`, `None`이 있으며, `Strict`는 외부 사이트에서    요청이 있을 경우 쿠키를 보내지 않는다.
      - **Spring Security**는 **세션 쿠키**를 직접 생성하지 않으므로 SameSite 속성에 대한     직접적인 지원을 제공하지 않는다.
      - **WebFlux** 기반 애플리케이션에서 SameSite 속성에 대한 **기본적인 지원**을 제공한다.
  
    - 로그인/로그아웃 보호
      - **로그인/로그아웃 요청**도 CSRF 공격의 대상이 될 수 있다.
      - 이를 방지하기 위해 로그인/로그아웃 요청도 **CSRF 토큰을 포함**시키는 방식으로 보호
  
  - **DNS 스니핑 (DNS Sniffing)**
    - DNS 요청을 모니터링하여 사용자가 방문하는 **웹사이트의 URL**을 추적하는 방식
    - 공격자는 사용자가 어떤 사이트에 방문했는지 추적하고 **개인 정보를 수집**
  - **네트워크 패킷 스니핑 (Packet Sniffing)**
    - **네트워크 트래픽**을 가로채어 **패킷**을 분석하는 공격 방법
    - 공격자는 네트워크 상의 데이터를 **몰래 캡처**하고, 이를 **분석**하여 **민감한 정보**를 추출
    - ex **암호화되지 않은 HTTP 트래픽**, **비밀번호**, **쿠키 정보** 등을 수집할 수 있다.

<br>

## **11.2 출력 값의 이스케이프 미비로 인한 취약성**
- 클라이언트에서 체크
    - 일반적으로 JS를 사용, 때문에 변조나 무효화될 가능성이 있어서 보안 대책으로 적합하지 않다.
    - 사용자 입력 값이 시스템 요건에 적합한지에 대한 정도 검증이 적절하다.
- 웹 애플리케이션(서버 측)에서 체크
    - 입력값 체크
    - 출력값 체크

### **크로스 사이트 스크립팅(XSS, cross-site scripting)**
- 웹 애플리케이션에서 사용자 입력값을 제대로 처리하지 않고 **웹 페이지에 삽입**할 수 있는 보안 취약점
- 공격자는 악의적인 **JavaScript 코드**를 웹 페이지에 삽입하여 다른 사용자의 브라우저에서 이를 실행하게 만든다.
- 사용자의 **세션 탈취**, **정보 유출**, **악성 코드 실행** 등 여러 가지 목적 수단으로 사용
- XSS의 종류
    - **반사형 XSS (Reflected XSS)**
        - 사용자가 악성 스크립트가 포함된 URL을 클릭하거나 요청을 보낼 때, 서버가 그 요청에 대한 응답을 바로 사용자에게 반환하면서 스크립트가 실행되는 방식
        - 공격자가 `http://example.com/search?query=<script>alert('XSS');</script>`와 같은 URL을 만들고, 피해자가 해당 링크를 클릭하면 브라우저에서 `alert('XSS')`라는 메시지가 표시 처리, 이는 사용자의 브라우저에서 악성 스크립트가 실행된 예시
    - **저장형 XSS (Stored XSS)**
        - 서버에 악성 스크립트가 저장되어, 나중에 다른 사용자가 해당 페이지를 요청할 때마다 스크립트가 실행
        - 악성 사용자가 댓글 입력란에 `<script>alert('XSS');</script>`와 같은 코드를 입력 후에, 서버는 이를 필터링하지 않고 그대로 저장하고, 나중에 다른 사용자가 그 페이지를 열면 악성 스크립트가 실행
    - **DOM 기반 XSS (DOM-based XSS)**
        - 클라이언트 측에서 JavaScript가 직접적으로 악성 스크립트를 실행하는 형태
        - 서버에서 데이터가 변형되지는 않지만, 클라이언트 측에서 DOM을 조작할 때 발생
        - `http://example.com?name=<script>alert('XSS');</script>`로 접속한 경우, JavaScript 코드가 이 파라미터를 처리할 때 악성 스크립트를 실행
- XSS 공격 방어 방법
    - 입력 값 검증 및 필터링
        - 사용자가 입력하는 데이터에 대해 HTML 태그나 JavaScript 코드를 필터링 처리
            - `<`, `>`, `"`, `'` 등의 특수 문자를 HTML 엔티티로 변환하이재킹
    - 출력 시 이스케이프(Escape)
        - 웹 페이지에 사용자 데이터를 출력할 때, 해당 데이터를 HTML, JavaScript, CSS 등의 컨텍스트에 맞게 이스케이프하여 실행되지 않도록 처리
    - 콘텐츠 보안 정책(CSP, Content Security Policy)
        - 웹 서버에서 CSP 헤더를 설정하여, 신뢰할 수 없는 출처의 스크립트가 실행되지 않도록 제한하기
    - HTTPOnly 및 Secure 쿠키 설정
        - 쿠키에 `HTTPOnly`와 `Secure` 속성을 설정하여 JavaScript에서 쿠키를 접근할 수 없게 하여 세션 하이재킹을 방지
