# If-XXX : 조건부 리퀘스트로 지정된 조건에 맞는경우에 서버가 리퀘스트를 받는다.

## If-Match

HTTP에서 **조건부 요청**을 처리할 때 사용되는 중요한 도구로, 주로 **경쟁 상태**를 방지하고 데이터 무결성을 유지하는 데 사용된다. 이 헤더는 클라이언트가 리소스를 수정하거나 삭제하기 전에, 리소스가 **예상대로 변경되지 않았음을 확인**하려고 할 때 사용된다.

- **변경되지 않았을 때 (ETag 일치)**: 요청을 **정상 처리**하고, 리소스를 수정하거나 삭제하며 새로운 ETag를 반환. (응답: `200 OK` 또는 `204 No Content`)
- **변경되었을 때 (ETag 불일치)**: 요청을 **거부**하고 오류 메시지를 반환. (응답: `412 Precondition Failed`)

### 핵심 기능과 용도:

1. **조건부 요청**: 클라이언트가 서버에서 리소스를 수정하거나 삭제하려고 할 때, **리소스의 상태가 변경되지 않았음을 확인**하는 조건을 추가한다.
2. **ETag 값 사용**: `If-Match` 헤더는 클라이언트가 이전에 서버에서 받은 **ETag 값을 사용**하여, 서버가 **현재 리소스의 ETag와 비교**하게 만든다. ( 참고 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag)
    - **ETag**는 리소스의 **고유 식별자**로, 리소스가 변경되면 ETag 값도 바뀐다.
3. **경쟁 상태 방지**: 클라이언트가 보낸 `If-Match` 값과 서버의 ETag 값이 일치하면 요청을 처리하고, **변경되었으면** (즉, ETag 값이 다르면) **요청을 거부한다.** 이 방식으로 두 명 이상의 사용자가 동시에 리소스를 수정하려 할 때 발생할 수 있는 **경쟁 상태**를 방지한다.

### 사용 시의 장점:

- **경쟁 상태 방지**: 두 명 이상의 클라이언트가 같은 리소스를 동시에 수정하려고 할 때 발생할 수 있는 충돌을 방지한다.
- **리소스의 일관성 보장**: 리소스가 수정되지 않은 상태에서만 요청이 처리되므로, 데이터의 정확성과 일관성이 유지된다.
- **무결성 확인**: 클라이언트는 리소스가 변경되지 않은 상태에서만 업데이트를 진행할 수 있으므로, 수정 과정에서 발생할 수 있는 오류를 예방할 수 있다.

### 주의점:

- **약한 ETag 사용 불가**: `If-Match`는 **정확한 ETag**를 요구하기 때문에, 서버가 리소스를 나타내는 약한 ETag(weak ETag)를 사용하는 경우, `If-Match` 헤더를 사용할 수 없다.
- **리소스 변경에 의존**: 클라이언트는 리소스를 **수정하기 전에 최신 ETag** 값을 반드시 받아야 하므로, ETag가 유효한지 확인하고 요청을 보내는 것이 중요하다.

### 사용 예시

```
PUT /items/123 HTTP/1.1
Host: example.com
If-Match: "abc123"
Content-Type: application/json
{
    "name": "Item A Updated",
    "price": 120
}
```

## If-Modified-Since

`If-Modified-Since`는 클라이언트가 서버에 **리소스가 변경된 이후에만** 데이터를 요청하도록 하는 조건부 헤더다. 이 헤더는 **서버가 리소스를 수정한 이후에만** 클라이언트에게 응답하도록 한다.

클라이언트가 서버에 리소스를 요청할 때, **리소스가 변경되지 않았으면 응답하지 않고**, 변경되었을 때만 응답을 받도록 한다. 이를 통해 **불필요한 데이터 전송을 줄이는 것을 목적으로 한다.**

- **리소스가 변경되지 않았을 때**
    - 서버는 리소스가 변경되지 않았다고 판단하고, **응답 본문 없이** `304 Not Modified` 상태 코드를 반환한다.
    - 이때, 클라이언트는 이전에 저장한 캐시된 데이터를 사용한다.
- **리소스가 변경되었을 때**
    - 서버는 리소스가 변경되었다고 판단하고, **새로운 리소스를 반환**한다.
    - 응답 코드 `200 OK`와 함께 수정된 리소스를 본문에 포함해서 반환한다.

---

### 사용 시 장점

- **네트워크 효율성**: 리소스가 변경되지 않았을 경우 **응답 본문을 보내지 않기** 때문에 네트워크 트래픽을 절감할 수 있다.
- **서버 부하 감소**: 서버는 리소스가 변경되지 않았을 때 본문을 전송하지 않으므로, 서버의 부하를 줄일 수 있다.
- **캐시 활용**: 클라이언트는 리소스가 변경되지 않았을 경우 **기존에 캐시된 리소스를 사용**하므로 더 빠른 응답을 받을 수 있다.

---

### 사용 시 주의점

- **정확한 수정 시간 관리**: 서버가 리소스의 정확한 **수정 시간을 기록**하고 있어야 한다. 이를 바탕으로 클라이언트가 요청할 때 올바른 수정 시간과 비교할 수 있다.
- **시간대 차이**: 클라이언트와 서버의 시간대가 다를 경우, 수정된 시점을 정확히 비교하는 데 문제가 생길 수 있다. 이로 인해 클라이언트가 의도하지 않게 **불필요한 데이터를 요청**할 수 있다.
- **캐시 제어**: `If-Modified-Since`는 **캐시된 데이터를 활용**하지만, 클라이언트가 실제로 데이터가 최신인지 확인하려면 **다시 서버로 요청**해야 하므로, **캐시 처리 방식에 주의**가 필요하다.

---

### 사용 예시

```
GET /items/123 HTTP/1.1
Host: example.com
If-Modified-Since: Mon, 1 Jan 2025 00:00:00 GMT
```

## If-None-Match

**리소스가 변경되지 않았을 때** 요청을 **허용하지 않도록** 하는 조건부 헤더다. 클라이언트는 `If-None-Match`에 서버의 **현재 ETag 값을 제공**하고, 서버는 해당 ETag와 **일치하지 않으면 요청을 처리**한다. 이 헤더는 **리소스를 가져올 때** 주로 사용된다.

- **목적**: 클라이언트가 특정 ETag 값을 제공하고, 서버의 리소스가 **해당 ETag와 일치하지 않으면** 리소스를 요청하는 방식이다. 즉, **리소스가 변경되었을 때만** 요청을 처리한다.
- **용도**: 서버의 리소스가 **수정된 경우에만** 데이터를 새롭게 요청하고, **수정되지 않았을 경우에는 캐시된 데이터를 사용**하도록 한다. 보통 **리소스를 조회할 때** 사용된다.

|  | **If-None-Match** | **If-Match** |
| --- | --- | --- |
| **목적** | 클라이언트가 제공한 ETag와 서버의 ETag가 **일치하지 않으면** 요청을 처리한다. | 클라이언트가 제공한 ETag와 서버의 ETag가 **일치할 때만** 요청을 처리한다. |
| **주요 용도** | 리소스를 **조회**할 때 사용. 리소스가 변경되었을 때만 새 데이터를 요청한다. | 리소스를 **수정**하거나 **삭제**할 때 사용. 리소스가 변경되지 않았음을 보장하려 한다. |
| **사용 시기** | 리소스의 **변경 여부**를 확인하고 변경된 경우 새 데이터를 요청. | 리소스를 수정하거나 삭제하기 전에 리소스가 **변경되지 않았음을 확인**. |
| **ETag 일치 시** | 리소스가 **변경되지 않았을 경우** 요청을 생략하고 `304 Not Modified` 응답. | 리소스를 **수정하거나 삭제**하고 `200 OK` 응답. |
| **ETag 불일치 시** | 리소스가 **변경되었을 경우** 새 데이터를 반환하고 `200 OK` 응답. | 리소스가 **변경되었을 경우** 요청을 거부하고 `412 Precondition Failed` 오류 응답. |
| **응답 코드** | `200 OK`, `304 Not Modified` | `200 OK`, `412 Precondition Failed` |
| **주요 기능** | 변경되지 않으면 캐시된 데이터 사용, 변경되었을 때만 새 데이터 요청. | 리소스가 변경되지 않았을 때만 요청을 허용하여 경쟁 상태 방지. |

## If-Range

`If-Range` 헤더는 클라이언트가 **부분적인 리소스**를 요청할 때 사용되며, 리소스가 특정 조건을 만족할 때만 범위 요청을 처리하도록 서버에 지시한다.

- **조건 만족 시**: 요청이 **부분적인 리소스를 반환**하도록 처리한다. (응답: `206 Partial Content`)
- **조건 불만족 시**: 요청을 **전체 리소스로 처리**하고, 전체 리소스를 반환한다. (응답: `200 OK`)

### 핵심 기능

1. **조건부 범위 요청**: 클라이언트가 범위 요청을 보내되, 서버는 리소스가 **변경되지 않았을 때**만 범위 요청을 처리한다. 만약 리소스가 변경되면, 클라이언트는 전체 리소스를 다시 받는다.
2. **ETag 또는 Last-Modified 값 사용**: `If-Range`는 **ETag** 또는 **Last-Modified** 값을 조건으로 사용하여 리소스의 상태를 판단한다.
    1.  **Last-Modified: 마지막으로 데이터가 수정된 시간**

### 사용 방안 및 케이스

1. **동영상 스트리밍**:
    - 대용량 비디오 파일을 스트리밍할 때, 사용자가 비디오의 일부만 다운로드한 후 **비디오가 수정되었는지 확인**할 필요가 있다.
    - 예를 들어, 비디오를 중간에 일시 정지한 후, `If-Range`를 사용하여 비디오의 **변경이 없을 경우**에만 이미 다운로드된 부분 이후의 데이터를 요청하고, 비디오가 변경되었으면 전체 데이터를 새로 다운로드하도록 한다.
    
    ```
    GET /video/12345 HTTP/1.1
    Host: example.com
    If-Range: "abc123"
    Range: bytes=10000-20000
    ```
    
    이 경우, 비디오의 ETag가 `"abc123"`일 때만 `bytes=10000-20000` 범위에 대해 요청을 보낸다.
    
2. **파일 다운로드 중 단절 시**:
    - 사용자가 파일 다운로드 도중에 인터넷 연결이 끊어졌을 때, `If-Range`를 활용하여 다운로드가 재개될 수 있도록 할 수 있다.
    - 서버는 이전에 다운로드된 부분에 대해 `If-Range`와 `Range` 헤더를 확인하고, 리소스가 변경되지 않았으면 **중단된 지점부터 다운로드를 이어서** 진행한다.
3. **캐시된 데이터 검증**:
    - 클라이언트가 캐시된 데이터를 사용하려는 경우, `If-Range`를 사용하여 캐시된 리소스가 서버에서 변경되지 않았을 때만 범위 요청을 처리하도록 할 수 있다.
    - 이 방식은 서버가 리소스를 갱신하지 않은 경우 클라이언트가 **기존 데이터를 재사용**하도록 해준다.

### 사용 시 장점

- **네트워크 효율성**: 리소스가 변경되지 않았다면 전체 데이터를 다시 다운로드할 필요 없이 **변경된 부분만**받아올 수 있어 네트워크 트래픽을 줄일 수 있다.
- **데이터 전송 시간 절약**: 클라이언트가 필요한 부분만 요청하므로, **빠르게 데이터를 전송**받을 수 있다.
- **다운로드 재개**: 다운로드가 중단되었을 때, `If-Range` 헤더를 사용하여 **중단된 부분부터 이어받기**가 가능하다.

### 주의점:

- **리소스 상태 관리**: 클라이언트가 사용하는 ETag 또는 Last-Modified 값이 정확해야 하며, 서버는 리소스가 변경되었는지 여부를 확인할 수 있는 최신 값을 제공해야 한다.
- **부분 요청의 일관성**: 범위 요청 중 리소스가 변경되면, 클라이언트는 전체 리소스를 다시 받아야 하므로 일관성을 관리해야 한다.

### 사용 예시

```
GET /audio/track.mp3 HTTP/1.1
Host: example.com
If-Range: "d5e3a92b1234567890"
Range: bytes=2000-4000
```

위의 예시에서, 클라이언트는 `"d5e3a92b1234567890"`라는 ETag를 조건으로 설정하여, 리소스가 변경되지 않았을 경우에만 2000번부터 4000번까지의 바이트 범위에 대해 요청을 보낸다.

## If-Unmodified-Since

지정된 시간 이후에 리소스가 **변경되지 않았을 경우에만** 요청을 처리한다. 예를들어 **리소스를 수정**하거나 **삭제**할 때, 클라이언트가 **리소스가 지정된 시점 이후로 변경되지 않았음을 확인**하려는 목적으로 사용된다.

클라이언트가 보낸 `If-Unmodified-Since` 값보다 **리소스가 더 최신인 경우**에는 요청을 거부하여 **경쟁 상태**를 방지한다. 즉, 다른 사용자가 이미 리소스를 변경한 경우, 클라이언트의 요청을 거부한다.

- **변경되지 않았을 때**: 요청을 **정상 처리**하고, 리소스를 수정하거나 삭제하며 새로운 데이터를 반환. (응답: `200 OK` 또는 `204 No Content`)
- **변경되었을 때**: 요청을 **거부**하고 오류 메시지를 반환. (응답: `412 Precondition Failed`)

### 사용 예시

```
PUT /items/123 HTTP/1.1
Host: example.com
If-Unmodified-Since: Mon, 1 Jan 2025 00:00:00 GMT
Content-Type: application/json
{
    "name": "Item A Updated",
    "price": 120
}
```

## **If-Unmodified-Since** vs **If-Match**

|  | **If-Unmodified-Since** | **If-Match** |
| --- | --- | --- |
| **목적** | 리소스가 지정된 시간 이후에 **변경되지 않았을 경우에만** 요청을 처리한다. | 클라이언트가 제공한 ETag와 서버의 ETag가 **일치할 때만** 요청을 처리한다. |
| **주요 용도** | 리소스를 **수정**하거나 **삭제**할 때 사용. 리소스가 특정 시간 이후로 변경되지 않았음을 확인. | 리소스를 **수정**하거나 **삭제**할 때 사용. 리소스의 **ETag가 일치**하는 경우에만 요청을 처리. |
| **시간 기반** | 리소스가 **특정 시간 이후** 변경되지 않았을 때만 요청을 처리. | ETag 값을 통해 리소스의 **변경 여부**를 확인. |
| **응답 코드** | `200 OK`, `204 No Content`, `412 Precondition Failed` | `200 OK`, `412 Precondition Failed` |
| **주요 차이점** | **시간 기반 조건** (Last-Modified)을 사용하여 리소스가 변경되지 않았을 때만 요청을 처리. | **ETag 기반 조건**을 사용하여 리소스의 변경 여부를 확인. |

## Max-Forwards

HTTP 요청이 **프록시 서버**나 **게이트웨이**와 같은 **중간 서버**를 통과할 때, 요청이 중간 서버에서 **얼마나 많은 횟수로 전달될 수 있는지**를 제한하는 헤더이다. 주로 **TRACE**나 **OPTIONS** 요청에서 사용되며, 요청의 추적이나 네트워크의 경로를 확인할 때 유용하다.

- **목적**: 요청이 전달될 수 있는 최대 횟수를 지정하여, 요청이 너무 많이 전달되는 것을 방지하고, 불필요한 네트워크 트래픽을 줄이는 데 도움을 준다.
- **값**: `Max-Forwards`의 값은 **정수**로 지정되며, 이 값은 요청이 중간 서버를 거쳐 전달될 수 있는 횟수를 나타낸다. 값이 0일 경우, 요청은 **최초 서버**에 도달하기 전에 더 이상 전달되지 않는다.

### **Max-Forwards가 0일 때 프록시에서의 처리**

`Max-Forwards` 헤더의 값이 **0**인 리퀘스트를 프록시 서버나 게이트웨이가 받으면, 해당 요청은 더 이상 다른 서버로 전달되지 않고 **직접 응답을 처리**하거나 **전달을 거부**할 수 있다.

**동작 예시:**

1. **`Max-Forwards: 0`이 포함된 요청**이 프록시 서버에 도달하면, 요청은 더 이상 다른 서버로 전달되지 않고 **프록시 서버에서 응답을 직접 처리한**다.
2. **응답 처리 예시**:
    - 프록시 서버가 요청을 처리하거나, 요청이 더 이상 전달될 수 없다고 판단할 경우 **`403 Forbidden`** 또는 **`400 Bad Request`** 등의 오류 응답을 반환할 수 있다.

### 사용 예시

```
TRACE / HTTP/1.1
Host: example.com
Max-Forwards: 3
```

### **핵심 포인트**

- `Max-Forwards` 헤더는 **TRACE**나 **OPTIONS** 요청에서 주로 사용되지만, **모든 HTTP 요청 메서드**에 적용할 수 있다.
- *`Max-Forwards: 0`*일 경우, 요청은 **더 이상 전달되지 않으며**, 해당 요청을 받은 프록시 서버가 **직접 처리**하거나 **응답을 거부**할 수 있다.
- **`Max-Forwards` 값**이 설정된 요청은 **최대 지정된 횟수**만큼 중간 서버를 거칠 수 있으며, 이 값을 초과하면 요청은 더 이상 전달되지 않는다.
- HTTP/2 에서는 연결 방식과 프록시 처리 방식이 달라졌기 때문에 `Max-Forwards` 헤더가 필요하지 않게 되었다.

## Proxy-Authorization

Authorization 과 마찬가지로 클라이언트 인증을 하는 것이며, 대상 이 서버가 아닌 프록시에 해당한다.

```
Authorization: <인증방식> <자격증명>
```

### 인증방식

BASIC - base64인코딩

Bearer - 토큰기반 인증

Digest, Custom - 해시를 또는 자체인증방식

## Range

**클라이언트가 리소스의 일부만 요청**할 때 사용된다. 일반적으로 **대용량 파일 다운로드, 동영상 스트리밍, 중단된 다운로드 재개** 시 유용하다. 

- 범위요청을 지원한다면  : **`206 Partial Content`** 응답과 함께 요청된 범위의 데이터를 반환
- 범위가 벗어나는 경우 : `416 Range Not Satisfiable` 응답
- 범위 요청을 지원하지 않는다면 : `200 OK` 응답과 함께 전체 범위 데이터 반환

### 사용 시 장점

- **대역폭 절약**: 필요한 데이터만 전송하여 네트워크 자원 사용 감소
- **빠른 응답 시간**: 전체 파일을 기다릴 필요 없이 **빠른 데이터 접근** 가능
- **중단된 다운로드 재개**: 다운로드 관리 프로그램에서 사용자가 **중단된 지점부터 이어받을 수 있음**
- **병렬 다운로드 지원**: 대용량 파일을 **여러 부분으로 나누어 동시에 다운로드**하여 처리 속도 향상
- **서버 부하 감소**: 서버가 전송해야 할 데이터량을 줄여 **서버 자원 절약**

### 사용 예시

- **오디오/비디오 스트리밍 서비스**
    - 사용자가 원하는 구간만 다운로드해 **즉각적인 재생** 지원
- **파일 다운로드 시스템**
    - **중단된 다운로드 이어받기** 및 **빠른 파일 전송**에 활용
- **분산 처리 및 대용량 로그 분석**
    - 필요한 부분만 추출해 **처리 시간 단축**

## Referer

클라이언트가 **현재 요청을 보낸 이전 웹 페이지의 URL**을 서버에 전달하는 헤더다.  서버와 웹 애플리케이션은 이를 통해 **요청 출처 확인**, **트래픽 분석**, **보안 정책 적용** 등의 다양한 용도로 활용할 수 있다

### **주요 기능 및 장점**

1. **트래픽 출처 분석**
    - 웹사이트 운영자는 Referer 정보를 사용하여 **사용자가 어떤 경로를 통해 접속했는지 파악**할 수 있다.
    - 이는 **마케팅 성과 측정**, **사이트 내 이동 경로 분석** 등에 유용하다.
2. **보안 및 접근 제어**
    - 서버는 Referer 값을 기반으로 **허용된 출처에서만 요청을 수락**할 수 있다.
    - 이를 통해 **CSRF(Cross-Site Request Forgery)**와 같은 공격을 방지하는 **기본적인 보안 수단**으로 활용된다.
3. **콘텐츠 제공 최적화**
    - 이미지, CSS, JS와 같은 **외부 리소스 요청 시 출처 확인**을 통해 불법적인 콘텐츠 핫링크(hotlinking)를 방지할 수 있다.

### **보안 및 개인정보 관련 고려사항**

- Referer 헤더는 민감한 정보(세션 ID, 사용자 정보 등)가 URL에 포함될 경우, **의도치 않게 외부에 노출**될 수 있다.
- 이러한 문제를 완화하기 위해, HTTP/1.1 이후에는 **Referrer-Policy** 헤더를 사용하여 **Referer 전송 범위를 제어**할 수 있다.
    - 예시:
        - `no-referrer`: Referer 정보를 전송하지 않음
        - `same-origin`: 동일 출처 요청에만 Referer 전송
        - `strict-origin-when-cross-origin`: 보안을 유지하면서도 편의성을 확보하는 **권장 정책**

흔히 볼 수 있는 것 : 쿠팡 연결링크

## TE

**TE 헤더**는 클라이언트가 서버에 **수신 가능한 전송 인코딩 방식**을 알리는 데 사용된다.  주로 **HTTP/1.1**에서 사용되며, **본문(body) 전송 시 인코딩된 데이터 처리**에 관한 정보를 제공한다. **Transfer-Encoding** 헤더와 관련이 있지만, **TE 헤더는 클라이언트 요청용**이고 **Transfer-Encoding은 서버 응답용이다.**

### TE 헤더 필드

- chunked, gzip, compress, deflate, identity, trailers 가 들어갈 수 있따.
    - **`trailers`**
        - HTTP/1.1에서는 **트레일러**가 응답의 끝 부분에 추가 정보를 포함하는 방식인데, 이 값은 주로 **청크 전송 인코딩**을 사용할 때 의미가 있다. 이 값은 `TE` 헤더에서 **트레일러의 사용 가능 여부**를 나타내는 데 사용된다.
        - 예시: `TE: chunked, trailers`

### TE vs Accept-Encoding

| **헤더** | **목적** | **예시** | **설명** |
| --- | --- | --- | --- |
| **Accept-Encoding** | 클라이언트가 받을 수 있는 콘텐츠 압축 형식 지정 | `Accept-Encoding: gzip, deflate` | 서버는 gzip 또는 deflate 방식으로 응답을 압축하여 보낼 수 있다. |
| **TE** | 클라이언트가 받을 수 있는 전송 인코딩 형식 지정 | `TE: chunked` | 서버는 응답을 청크 단위로 나누어 전송할 수 있다. |

**주요 차이점:**

- **Accept-Encoding**: 데이터를 어떻게 압축할지에 관한 것.
- **TE**: 데이터가 어떻게 전송될지에 관한 것.

## User-Agent

클라이언트(브라우저, 앱 등)가 서버에 요청(리퀘스트)을 보낼 때, 자신이 사용하는 소프트웨어와 운영 체제 정보를 서버에 전달하는 헤더이다. 보통 브라우저 종류, 버전, 운영 체제, 디바이스 정보 등이 포함된다.

**예시**

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36
```

- **용도**:
    - 서버가 클라이언트의 환경에 맞게 최적화된 콘텐츠를 제공할 수 있도록 한다.
    - 웹사이트는 User-Agent 정보를 통해 브라우저나 디바이스에 맞는 스타일을 적용하거나 기능을 다르게 처리할 수 있다.
- **주의사항**:
    - User-Agent 값은 쉽게 변조될 수 있어, 보안적인 목적에서는 신뢰할 수 없는 정보로 취급할 수 있다.
