# 6.3) HTTP/1.1 일반 헤더 필드
일반헤더는 리퀘스트 메세지와 리스폰스 메세지에 모두 사용하는 헤더다.

## 6.3.1 Cache-Control

- 관련 rfc : https://datatracker.ietf.org/doc/html/rfc7234#section-5.2
- 캐시가 요청 및 응답을 어떻게 처리할지 결정과 관련된 헤더. **요청** 과 **응답** 모두에서 사용될 수 있으며, 그 안에 포함된 디렉티브들이 요청과 응답에 따라 다르게 적용된다.
- 특징
    - **지침의 일방향성**:
        - 캐시 설정은 요청과 응답에 각각 다르게 설정될 수 있다.
        - 요청에 있는 설정은 응답에 반드시 같은 설정이 포함된다고 가정할 수 없다.
        - 프록시는 설정이 특정 캐시에 적용되는지와 관계없이, 설정을 전달해야 한다. 이는 모든 수신자에게 적용될 수 있기 때문이다.(end to end)

### 요청(Cache-Control) 디렉티브

1. **max-age**:
    - **목적**: 클라이언트는 지정된 시간(초)보다 오래된 응답을 수락하지 않는다.
    - **동작**: 지정된 시간보다 오래된 응답은 거부된다.
2. **max-stale**:
    - **목적**: 클라이언트는 최대한 오래된 응답을 수락할 수 있다.
    - **동작**: 지정된 시간보다 오래된 응답도 수락할 수 있다.
3. **min-fresh**:
    - **목적**: 클라이언트는 응답이 최소한 지정된 시간 동안 신선하게 유지될 수 있기를 원한다.
    - **동작**: 지정된 시간 동안 신선한 응답을 유지할 수 있기를 원한다.
4. **no-cache**:
    - **목적**: 캐시된 응답을 원 서버에서의 유효성 검사 없이 사용할 수 없다.
    - **동작**: 캐시된 응답을 사용하려면 원 서버에서 유효성 검사를 반드시 거쳐야 한다.
5. **no-store**:
    - **목적**: 요청이나 응답의 어떤 부분도 저장해서는 안 된다.
    - **동작**: 요청 및 응답을 캐시하지 않으며 저장하지 않는다.
6. **no-transform**:
    - **목적**: 중개자는 응답의 내용을 변경해서는 안 된다.
    - **동작**: 중개자는 응답을 변형하지 않는다.
7. **only-if-cached**:
    - **목적**: 클라이언트는 저장된 응답만을 원한다.
    - **동작**: 저장된 응답이 없으면 504 상태 코드가 반환된다.

### 응답(Cache-Control) 디렉티브

1. **must-revalidate**:
    - **목적**: 응답이 만료된 후에는 캐시가 원 서버에서의 유효성 검사 없이 응답을 사용할 수 없다.
    - **동작**: 응답이 만료되면 유효성 검사를 반드시 거쳐야 한다.
2. **no-cache**:
    - **목적**: 응답을 사용하려면 원 서버에서의 유효성 검사가 필요하다.
    - **동작**: 응답을 사용하기 전에 원 서버에서 유효성 검사를 거쳐야 한다.
3. **no-store**:
    - **목적**: 캐시는 요청 및 응답을 저장해서는 안 된다.
    - **동작**: 요청 및 응답 모두 캐시하지 않는다.
4. **no-transform**:
    - **목적**: 중개자는 응답의 내용을 변경해서는 안 된다.
    - **동작**: 중개자는 응답을 변형하지 않는다.
5. **public**:
    - **목적**: 응답은 공용 캐시에 저장될 수 있다.
    - **동작**: 응답은 공용 캐시에 저장될 수 있다.
6. **private**:
    - **목적**: 응답은 개인 캐시에만 저장되어야 한다.
    - **동작**: 응답은 개인 캐시에만 저장된다.
7. **proxy-revalidate**:
    - **목적**: 개인 캐시에는 적용되지 않으며, 공유 캐시에만 유효성 검사를 요구한다.
    - **동작**: 공유 캐시에서 유효성 검사가 필요하다.
8. **max-age**:
    - **목적**: 응답은 지정된 시간이 지난 후에는 신선하지 않다고 간주된다.
    - **동작**: 지정된 시간이 지나면 응답이 만료된다.
9. **s-maxage**:
    - **목적**: 공유 캐시에서만 max-age보다 우선시된다. max-age와 동일하게 동작한다.
    - **동작**: 공유 캐시에서 `max-age`보다 우선하여 적용된다.

| **디렉티브** | **설명** | **요청/응답** |
| --- | --- | --- |
| **max-age** | 지정된 시간(초) 후 응답은 만료되며, 더 오래된 응답을 거부 | 요청/응답 |
| **max-stale** | 지정된 시간보다 오래된 응답을 수락할 수 있음 | 요청 |
| **min-fresh** | 응답이 최소한 지정된 시간 동안 신선하게 유지되도록 요구 | 요청 |
| **no-cache** | 캐시된 응답을 원 서버에서 유효성 검사 없이 사용할 수 없음 | 요청/응답 |
| **no-store** | 요청이나 응답의 어떤 부분도 저장하지 않음 | 요청/응답 |
| **no-transform** | 중개자가 응답을 변경하지 않도록 요구 | 요청/응답 |
| **only-if-cached** | 저장된 응답만을 원함, 저장되지 않으면 504 상태 코드 반환 | 요청 |
| **must-revalidate** | 응답이 만료되면 캐시가 원 서버에서 유효성 검사를 거쳐야 함 | 응답 |
| **public** | 응답은 모든 캐시에 저장 가능 | 응답 |
| **private** | 응답은 개인 캐시에만 저장 가능 | 응답 |
| **proxy-revalidate** | 공유 캐시에는 적용되지 않으며, 개인 캐시에만 유효성 검사 적용 | 응답 |
| **s-maxage** | 공유 캐시에서만 적용되는 max-age, 우선시됨 | 응답 |

## 6.3.2 Connection

관련 rfc :https://datatracker.ietf.org/doc/html/rfc7230#section-6.1

**"Connection"** 헤더 필드는 현재 연결에 대한 제어 옵션을 지정할 수 있도록 해준다. 이를 통해 보내는 쪽은 연결에 대해 원하는 제어 옵션을 설정할 수 있다. **프록시**나 **게이트웨이**는 메시지를 전달하기 전에 수신한 연결 옵션을 제거하거나 교체해야 한다.

- rfc규약)
    - 프록시나 게이트웨이는 **Connection** 헤더 필드를 파싱한 후, 해당 필드 내의 연결 옵션에 맞는 헤더들을 메시지에서 제거하고, 그 후 **Connection** 헤더 필드를 제거하거나, 그들의 연결 옵션으로 교체하여 메시지를 전달해야 한다.
    - 이렇게 함으로써, **Connection** 헤더 필드는 "즉시 수신자"만을 위한 헤더(예: hop-by-hop)와 "전체 경로의 수신자"를 위한 헤더(예: end-to-end)를 구별할 수 있도록 한다. 이를 통해 메시지가 자체적으로 설명 가능하며, 미래의 연결 관련 확장이 이전의 중간 장비들에 의해 잘못 전달되는 것을 방지할 수 있다.

- **close**
    - 연결을 종료할 것임을 나타냄.
    - 예: `Connection: close`
    - **특징**: 요청 또는 응답이 완료된 후 연결을 종료한다는 의미.
- **keep-alive**
    - 연결을 열린 상태로 유지하려는 의도를 나타냄.
    - 예: `Connection: keep-alive`
    - **특징**: HTTP/1.1에서는 기본적으로 연결을 유지하지만, 이 옵션을 명시적으로 설정하여 연결을 끊지 않음.(HTTP/1.0까지는 디폴트 설정이 아님)
- **upgrade**
    - 현재의 연결을 다른 프로토콜로 업그레이드하겠다는 의도를 나타냄.
    - 예: `Connection: upgrade`
    - **특징**: "Upgrade" 옵션과 함께 사용되어, HTTP 연결을 WebSocket과 같은 다른 프로토콜로 변경함.

## 6.3.3 Date

rfc : https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2

- Date 헤더 필드가 생성될 때, 발신자는 메시지 생성 시점의 날짜와 시간을 가장 잘 근사한 값으로 필드 값을 생성해야 한다. 이론적으로, 날짜는 페이로드가 생성되기 직전의 순간을 나타내야 한다. 하지만 실제로는 메시지가 생성되는 동안 언제든지 날짜를 생성할 수 있다.
- 형식
    
    ```
    Date: Tue, 15 Nov 1994 08:12:31 GMT
    ```
    
- rfc규약)
    
    서버는 현재 UTC 시간을 정확히 알 수 없으면, Date 헤더 필드를 전송해서는 안 된다. 하지만  서버가 상태 코드가 1xx(Informational) 또는 5xx(Server Error)인 경우에는 UTC시간을 알지 못해도 Date 헤더 필드를 전송할 수 있다. 그 외의 경우에는 반드시 Date 헤더 필드를 포함해야 한다.
    
    응답 메시지를 받는 수신자는 Date 헤더 필드가 없는 경우 메시지를 받은 시간을 기록해야 하며, 해당 메시지가 캐시되거나 다운스트림(프록시에 해당)으로 전달될 경우 해당 시간에 맞는 Date 헤더 필드를 메시지 헤더에 추가해야 한다.
    

### **Date 헤더 필드의 필요성 및 중요성**

1. **응답의 타임스탬프 제공**
    
    Date 헤더는 메시지가 생성된 시간을 나타낸다. 이를 통해 클라이언트는 서버가 해당 응답을 언제 생성했는지 알 수 있으며, 응답이 최신 정보인지 여부를 판단할 수 있다.
    
2. **캐시 관리**
    
    Date 헤더는 캐시 시스템에서 중요한 역할을 한다. 서버의 응답이 언제 생성되었는지를 확인함으로써, 캐시된 콘텐츠가 최신 상태인지, 만료되었는지 확인할 수 있다.
    
3. **응답의 신뢰성 보장**
    
    응답 메시지가 언제 생성되었는지를 명시적으로 제공하여, 클라이언트가 서버의 응답이 정확하고 최신 정보인지 확인할 수 있다. 이는 특히 시간 차이가 큰 서버들이 있을 때 유용하다.
    
4. **메시지 순서와 일관성 보장**
    
    여러 서버가 연속적으로 응답을 보낼 때, Date 헤더는 메시지의 순서를 명확하게 하고, 각 서버가 보낸 응답이 올바른 시간에 맞춰서 발생했음을 보장한다.
    
5. **HTTP 프로토콜의 일관성 유지**
    
    HTTP는 표준화된 날짜 형식인 HTTP-date를 사용하여 메시지 타임스탬프를 기록한다. 이를 통해 다양한 서버와 클라이언트가 일관되게 날짜를 처리할 수 있다.
    

## 6.3.4 Pragma

**`Cache-Control` 헤더가 이 역할을 대신한다.**

## 6.3.5 Trailer

- rfc : https://datatracker.ietf.org/doc/html/rfc7230#section-4.4
- **Trailer** 헤더는 HTTP 메시지에서 본문 뒤에 추가적인 헤더 필드를 포함시키는 기능을 제공한다. 주로 **chunked transfer encoding**을 사용할 때 유용하다. `Trailer` 헤더는 `Transfer-Encoding: chunked`와 결합되어 사용된다. 이는 메시지가 여러 청크로 나누어져 있을 때, 청크가 끝난 후에 추가적인 헤더 정보를 전송할 수 있게 해준다. 이를 통해 본문과 함께 전송되지 않지만, 이후에 필요한 정보를 헤더로 추가할 수 있다.

### 사용 예시

```
Transfer-Encoding: chunked
Trailer: Max-Forwards, X-Custom-Header

... (청크된 본문)

0

Max-Forwards: 10
X-Custom-Header: CustomValue
```

위 예시에서, 본문을 청크로 나누어 보내고, 본문이 끝난 후에 `Max-Forwards`와 `X-Custom-Header`가 `Trailer` 헤더에 포함되어 전달된다.

### Trailer가 필요한 이유

1. **청크 전송 방식에서의 제한**:
    - **청크 전송 인코딩**(Chunked Transfer Encoding)은 데이터를 작은 청크로 나누어 전송한다. 이 방식에서는 전체 본문 크기를 사전에 알 수 없기 때문에, 본문이 끝난 후에 추가적인 정보를 헤더로 전송할 필요가 있을 때 **Trailer** 헤더를 사용한다.
    - 본문이 모두 전송된 후에, 그때서야 결정되는 추가적인 헤더 값을 전송하려면 **Trailer**가 필요하다. 예를 들어, 응답 본문이 크기나 처리 시간에 따라 달라지거나, 본문 내용이 처리되면서 계산되는 값이 있을 때 이를 **Trailer** 헤더로 전송할 수 있다.
2. **동적으로 결정되는 정보 추가**:
    - 서버가 응답 본문을 청크로 전송하는 경우, 일부 값은 본문이 끝난 후에야 정확히 계산될 수 있다. 예를 들어, 본문을 전송하고 난 후에 요청 처리 결과나 상태 정보를 헤더로 전달해야 할 때 **Trailer**가 필요하다.
    - 예를 들어, 대량의 데이터를 처리하는 서버는 파일을 전송하는 동안 전체 크기나 처리 상태를 청크 전송 방식으로 보내고, 마지막 청크에서 해당 값을 **Trailer** 헤더로 전달한다.
3. **HTTP 메시지의 크기 결정 후 전송**:
    - 청크 전송 인코딩을 사용할 때는 **메시지 크기**가 본문 전송 도중 결정되거나, 그 후에야 알게 된다. 이때 크기나 처리 상태와 같은 정보를 메시지 끝부분에서 **Trailer** 헤더를 사용해 전송할 수 있다.
4. **전송 중에 중요한 정보가 결정되는 경우**:
    - 응답을 청크로 보내는 동안 서버는 본문 내용이나 결과에 따라 중요한 정보를 마지막에 추가하고자 할 수 있다. 이때 **Trailer** 헤더를 사용하여 동적으로 생성된 정보를 헤더로 추가한다.

## 6.3.6 Transfer-Encoding

rfc : https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.1 

**Transfer-Encoding 헤더 필드**는 메시지 본문을 구성하는 전송 인코딩을 나열한다. 이 헤더는 메시지 본문을 생성할 때 적용된 전송 인코딩들을 나타내며, 이는 주로 전송 효율성이나 보안을 위해 적용된다. **Transfer-Encoding**은 MIME의 **Content-Transfer-Encoding**과 유사하지만, HTTP에서는 동적으로 생성된 본문을 정확히 구분하고, 선택된 리소스의 특징을 나타내기보다는 전송을 효율적으로 하기 위해 사용된다.

**Transfer-Encoding의 사용 예시**:

- `Transfer-Encoding: gzip, chunked`는 메시지 본문이 **gzip** 방식으로 압축된 후, **청크 전송 인코딩** 방식으로 전송되었음을 의미한다.

**Transfer-Encoding의 특성**:

- **Content-Encoding**과 다르게 **Transfer-Encoding**은 메시지의 특성이지, 리소스의 특성이 아니다. 즉, 요청/응답 체인에서 수신자는 **Transfer-Encoding**을 처리할 수 있으며, 필요에 따라 추가적인 전송 인코딩을 적용할 수 있다.
- **Transfer-Encoding**은 **HEAD** 요청이나 **304 (Not Modified)** 응답에도 전송될 수 있다. 하지만 **응답 메시지**에는 **1xx (정보성 응답)**이나 **204 (내용 없음)** 상태 코드에서 이 헤더를 보내지 않는다.

### Transfer-Encoding 사용 예시

1. **단일 전송 인코딩 예시**
    - 메시지 본문이 **gzip** 방식으로 압축된 후 전송되는 경우:이 경우, 서버는 응답 본문을 **gzip** 형식으로 압축하여 전송한다. 클라이언트는 이를 풀어서 원본 데이터를 받는다.
        
        ```
        Transfer-Encoding: gzip
        ```
        
2. **복합 전송 인코딩 예시**
    - 메시지 본문이 **gzip**으로 압축되고, 그 후 **chunked** 인코딩이 적용된 경우:이 경우, 서버는 먼저 응답 본문을 **gzip**으로 압축한 뒤, 이를 **chunked** 방식으로 전송한다. 클라이언트는 먼저 **chunked**로 나눠진 청크를 받고, 각 청크는 **gzip**으로 압축된 형태로 포함된다. 클라이언트는 이를 풀고 다시 원본 데이터를 복원한다.
        
        ```
        Transfer-Encoding: gzip, chunked
        ```
        
3. **청크 전송 인코딩만 사용 예시**
    - 메시지 본문이 크기가 미리 결정되지 않아서 **chunked** 인코딩 방식만 사용되는 경우:이 경우, 서버는 메시지 본문을 **청크**로 나누어 전송한다. 청크는 각 부분의 크기와 데이터를 포함하고 있으며, 전송이 완료되면 `0\r\n\r\n`으로 메시지 끝을 표시한다. 클라이언트는 이를 받아서 처리한다.
        
        ```
        Transfer-Encoding: chunked
        ```
        
4. **복합 전송 인코딩 예시 - 복잡한 경우**
    - 메시지 본문이 먼저 **deflate** 방식으로 압축되고, 그 후 **chunked** 방식으로 전송되는 경우:이 경우, 서버는 응답 본문을 **deflate** 방식으로 압축하고, 그 후 **chunked**로 나누어 전송한다. 클라이언트는 먼저 **chunked**로 분할된 데이터를 받고, 각 청크는 **deflate** 형식으로 압축되어 있어, 이를 풀어 원본 데이터를 복원한다.
        
        ```
        Transfer-Encoding: deflate, chunked
        ```
        

**Content-Encoding vs Transfer-Encoding 조사가 필요해보임**

## 6.3.7 Upgrad

### 1. **개념: HTTP/1.1의 `Upgrade` 헤더**

HTTP/1.1에서 `Upgrade` 헤더는 클라이언트가 서버에 다른 프로토콜로의 업그레이드를 요청하는 데 사용됩니다. 이를 통해 HTTP 연결을 유지하면서도 다른 프로토콜로 전환할 수 있습니다. 주로 WebSocket과 같은 양방향 통신을 위해 사용됩니다.

`Upgrade` 헤더의 형식은 다음과 같습니다:

```
pgsql
복사
Upgrade: protocol-name, protocol-name

```

여기서 `protocol-name`은 클라이언트가 요청하는 프로토콜을 나타냅니다.


### 2. **예시: WebSocket 업그레이드**

WebSocket을 사용하여 HTTP 연결을 WebSocket 프로토콜로 업그레이드하는 예시입니다. WebSocket은 HTTP 연결을 바탕으로 양방향 통신을 가능하게 하므로, `Upgrade` 헤더를 사용하여 이를 요청할 수 있습니다.

```
makefile
복사
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9eob2eA==
Sec-WebSocket-Version: 13

```

서버는 `101 Switching Protocols` 상태 코드와 함께 연결을 WebSocket으로 업그레이드하게 됩니다.

### 나의 말:

~다라고 이야기해달라니까

### ChatGPT의 말:

알겠습니다! "~다" 형식으로 다시 설명드리겠습니다.

### 1. **개념: HTTP/1.1의 `Upgrade` 헤더**

HTTP/1.1에서 `Upgrade` 헤더는 클라이언트가 서버에 특정 프로토콜로 업그레이드를 요청하는 데 사용된다. 이 헤더를 통해 클라이언트는 HTTP 연결을 유지하면서 다른 프로토콜로 전환할 수 있음을 알린다. 주로 WebSocket과 같은 양방향 통신을 요청할 때 사용된다.

### 2. **예시: WebSocket 업그레이드**

WebSocket 프로토콜로의 업그레이드를 요청하는 예시가 있다. 클라이언트가 HTTP/1.1 연결을 WebSocket으로 업그레이드하려면 `Upgrade` 헤더를 포함시켜 요청한다. 서버는 이를 받아 `101 Switching Protocols` 응답을 통해 업그레이드를 완료한다.

```

GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9eob2eA==
Sec-WebSocket-Version: 
```

서버는 이를 받아 WebSocket 연결로 전환한다.

### 3. **예시: HTTP/2 업그레이드**

클라이언트가 HTTP/1.1을 사용해 요청을 보내고, 이를 HTTP/2로 업그레이드하려면 `Upgrade` 헤더를 사용한다. 이때 `h2c` 프로토콜을 요청하여 HTTP/1.1에서 HTTP/2로 전환할 수 있다.

```
Upgrade: h2c
Connection: Upgrade
```

서버가 이를 수락하면, 연결이 HTTP/2로 업그레이드된다.

## 6.3.8 Via

### 1. **개념: `Via` 헤더**

`Via` 헤더는 HTTP 요청이나 응답이 중간 서버를 거쳐서 전달될 때, 그 경로를 추적하기 위해 사용된다. 주로 프록시 서버나 게이트웨이 서버를 거치는 경로 정보를 나타낸다. 이를 통해 메시지가 어느 서버를 거쳤는지 추적할 수 있으며, 이 정보는 디버깅이나 오류 추적에 유용하다.

### 2. **형식: `Via` 헤더**

`Via` 헤더는 여러 서버를 거칠 수 있기 때문에 여러 개의 값을 쉼표로 구분하여 나열할 수 있다. 형식은 다음과 같다:

```
php-template
복사
Via: <protocol> <version> <hostname>

```

- `<protocol>`: 사용된 프로토콜(예: HTTP)
- `<version>`: 프로토콜 버전(예: 1.1)
- `<hostname>`: 서버의 호스트명

### 3. **예시: 프록시 서버를 거친 요청**

클라이언트가 요청을 보낼 때 프록시 서버를 거친 경우, `Via` 헤더가 포함된다. 예를 들어, 클라이언트가 프록시 서버를 통해 HTTP 요청을 보냈다면, 요청 헤더에 `Via` 정보가 추가된다.

```
makefile
복사
Via: 1.1 proxy.example.com

```

이는 요청이 `proxy.example.com`이라는 프록시 서버를 거쳐 전달되었음을 나타낸다.

### 4. **예시: 여러 서버를 거친 경우**

`Via` 헤더는 여러 서버를 거쳤을 경우, 각각의 서버 정보를 순차적으로 나열할 수 있다. 예를 들어, 클라이언트가 프록시 서버를 거쳐 다른 프록시 서버로 전달된 경우, `Via` 헤더는 다음과 같이 표시된다.

```
makefile
복사
Via: 1.1 proxy1.example.com, 1.1 proxy2.example.com

```

이 경우, 요청이 `proxy1.example.com`을 거쳐 `proxy2.example.com`으로 전달되었음을 알 수 있다.

## 6.3.9 Warning

### 1. **개념: `Warning` 헤더**

`Warning` 헤더는 HTTP 응답 메시지에 대한 경고 정보를 클라이언트에게 전달하기 위해 사용된다. 이 헤더는 주로 서버가 응답을 처리할 때 발생할 수 있는 잠재적인 문제나 특이사항을 알리는 데 사용된다. 클라이언트는 이를 바탕으로 추가적인 처리를 하거나 경고를 사용자에게 전달할 수 있다.

### 2. **형식: `Warning` 헤더**

`Warning` 헤더는 여러 개의 경고 메시지를 포함할 수 있으며, 각 경고는 다음과 같은 형식으로 작성된다:

```
php-template
복사
Warning: <code> <text> <date>

```

- `<code>`: 경고 코드 (3자리 숫자)
- `<text>`: 경고의 설명
- `<date>`: 경고 발생 시간을 나타내는 날짜(옵션)

### 3. **예시: 경고 메시지**

서버가 응답을 반환할 때, 특정 조건이나 상태에 대해 경고를 포함시킬 수 있다. 예를 들어, 캐시된 콘텐츠가 오래되었거나, 서버에 일시적인 문제가 있을 때 경고를 보낼 수 있다.

```
vbnet
복사
Warning: 110 Response is stale

```

위 경고는 클라이언트에게 응답이 오래된(즉, 캐시된) 데이터라는 것을 알리는 경고 메시지이다.

### 4. **예시: 경고와 날짜 포함**

경고 메시지에 발생 시간을 포함시킬 수도 있다. 예를 들어, 서버가 네트워크 상태로 인해 지연된 응답을 보낼 때 경고를 추가할 수 있다.

```
pgsql
복사
Warning: 199 Miscellaneous warning "Server is under heavy load" "Wed, 23 Feb 2025 10:00:00 GMT"

```

이 경고는 서버가 과중한 부하로 인해 응답에 지연이 있을 수 있다는 정보를 클라이언트에 전달하는 것이다.

### 5. **경고 코드 예시**

`Warning` 헤더에는 여러 가지 경고 코드가 존재하며, 각 코드에 따라 경고의 종류가 달라진다. 예를 들어:

- **110**: 응답이 오래된(stale) 데이터임.
- **199**: 다양한 이유로 발생한 기타 경고.
- **301**: 응답에서 리소스가 변경되었으므로 새로 고침이 필요함.
