# 7.1 HTTP의 약점
약점 (도청, 위변조)
- 평문 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

네트워크 상의 패킷은 언제든지 수집 가능함.
 
암호화로 도청을 방어함.
1) 통신 암호화
http에는 암호화 기능이 없지만, SSL, TLS등을 같이 사용해서 암호화함.
SSL등을 사용해서 안전한 통신로를 확보하고 나서, 그 통신로를 활용해 HTTP통신을 합니다.
SSL을 조합한 것은 HTTPS라고 합니다.

2) 콘텐츠 암호화
통신하고 있는 내용 자체를 암호화
평소 브라우저에서 사용되지는 않고, 웹서버에서 사용됨.

## 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능
리퀘스트를 보낸 서버가 정말로 URI에서 지정된 호스트인지 아닌지 , 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 아닌지 모름.

- 이상한 웹서버가 대신 반환가능함.
- 요청 클라이언트가 위장될 가능성.
- 허가된 상대인지 아닌지 판단 불가능.
- 대량의 request에 의한 dos공격가능성.

SSL로 상대 확인가능. 신뢰할 수 있는 제 3자에 의해서 증명서 발급해서 서로 진짜임을 확인함.

SSL 3.0은 이미 오래전에 취약점 때문에 사용이 권장되지 않아.
최신 버전은 TLS 1.3(1.2도 여전히 널리 사용). 보통 SSL 설정이라 해도 실제론 TLS를 쓰는 경우가 많다.

### SSL/TLS 동작 원리(핸드셰이크)

### ClientHello
클라이언트가 서버에게 “이런 암호 알고리즘(사이프 스위트)들을 쓸 수 있어요. SSL/TLS 버전은 이만큼 지원해요”라고 알려줌.
### ServerHello
서버가 “그럼 이 중에서 ○○ 알고리즘을 쓰자. 인증서는 이거야”라고 클라이언트에게 응답.
서버는 X.509 인증서(일반적으로 RSA/EC 기반)를 클라이언트에게 보낸다.
### 서버 인증서 검증
클라이언트는 서버의 인증서가 **신뢰할 수 있는 CA(Certificate Authority)**에서 발급된 것인지 확인한다.
인증서가 문제 없다면 다음 단계로 진행.
### 키 교환(Key Exchange)
클라이언트와 서버는 서로 세션에 쓸 **대칭키(세션키)**를 안전하게 교환.
RSA, ECDHE(Elliptic Curve Diffie-Hellman Ephemeral) 같은 알고리즘이 동원된다.
### 대칭 암호화 통신 시작
이제 두 측은 합의된 키로 데이터(HTTP 메시지 등)를 대칭암호로 암호화하여 통신.
메시지 무결성 검증을 위한 MAC이나 해시를 추가로 사용.

## 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능
중간자 공격(man in the middle 공격)에 의해서 중간에 데이터가 바뀔 수 있음.

MD5, SHA-1 등의 해시값 확인을 통해서 방어중.

하지만 유저가 의도적으로 검사해야함. 브라우저가 자동으로 하지는 않음.

하지만 이것도 100%는 아님.

# 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS
키만 공개키 암호화로 교환하고
데이터는 공통키 암호화로 교환한다

공개키 암호화 자체의 위변조를 막기 위해서 CA에서 발행한 인정서를 활용함.



---
# 질문
