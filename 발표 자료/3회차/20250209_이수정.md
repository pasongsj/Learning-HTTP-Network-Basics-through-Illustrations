## 2.3) HTTP는 상태를 유지하지 않는 프로토콜

### **HTTP는 stateless한 프로토콜이다**

**HTTP**는 **stateless**한 프로토콜로 설계되었다. 이는 **서버가 클라이언트의 상태를 저장하지 않**고, **각 요청은 독립적으로 처리**된다는 의미이다. 즉, **서버는 이전의 요청이나 응답을 기억하지 않**고, 요청이 있을 때마다 그때그때 상태를 처리한다.

### **HTTP의 특징:**

1. **독립적인 요청 처리**: 각 HTTP 요청은 **독립적**으로 처리된다. 서버는 이전의 요청이나 응답에 대한 정보를 기억하지 않는다.
2. **상태 정보 저장 없음**: HTTP는 상태를 유지하지 않으므로, 클라이언트와 서버 간의 **상태 추적**을 위해 추가적인 메커니즘이 필요하다.
3. **단순성 및 확장성**: stateless한 특성 덕분에 HTTP는 단순하고, 서버에 부담을 주지 않으면서도 **확장성이 뛰어난** 프로토콜이다.

### **HTTP가 상태를 유지하기 위한 방법들:**

HTTP는 **stateless**하기 때문에, **상태를 유지**하려면 외부 방법을 사용해야 한다. 대표적인 방식으로는 **세션**, **쿠키**, JWT(JSON Web Token)가 있다.

| **기술** | **설명** | **장점** | **단점** |
| --- | --- | --- | --- |
| 세션(Session) | 서버에서 클라이언트의 상태를 서버 측에 저장하는 방식 | 서버에서 상태를 관리하므로 보안성이 좋고, 정보 추적이 용이함 | 서버 리소스를 소모하며, 서버 확장이 어려울 수 있음 |
| 쿠키(Cookie) | 클라이언트의 브라우저에 상태 정보를 저장하는 방식 | 서버에 부담을 주지 않으며, 클라이언트에서 상태를 관리할 수 있음 | 보안 취약점, 크기 제한, 민감한 정보 저장 위험 |
| JWT (토큰) | 클라이언트-서버 간 상태를 토큰으로 관리하는 방식 | 서버에서 상태를 저장하지 않고도 인증을 유지할 수 있으며, 분산 시스템에 유리하고 서버 확장성이 좋음 | 토큰 만료 및 보안 취약점, 민감한 정보 저장 불가 |

### **HTTP Keep-Alive 헤더**

- **Keep-Alive**는 HTTP 연결을 재사용하기 위한 메커니즘이다. 기본적으로 HTTP는 각 요청마다 **새로운 연결을 생성**하고 응답 후 이를 닫는다. 하지만 **Keep-Alive**를 사용하면, 하나의 연결을 **여러 요청에 걸쳐 재사용**할 수 있어 성능을 향상시킨다.
- **작동 방식**: HTTP 헤더에 `Connection: keep-alive`를 추가하면, 서버는 연결을 일정 시간 동안 유지하며, 클라이언트가 추가적인 요청을 보낼 때 **새로운 연결을 열지 않고 기존 연결을 재사용**한다.
- **장점**: 연결 재사용으로 인한 네트워크 성능 향상(연결 설정과 해제에 드는 시간을 절약).
- **단점**: 연결이 일정 시간 유지되므로 **서버 자원을 차지**할 수 있고, 연결 유지 시간이 너무 길면 **서버에 부담을 줄** 수 있다.

## 2.4) 리퀘스트 URI로 리소스 식별

### HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다.

- MultiHost(다중호스트)를 사용하는 경우
    - **다중 호스트**는 동일한 **IP 주소**에서 **여러 개의 호스트**나 **서비스**를 식별하는 방식이다. 이때, **URI**를 사용하여 특정 리소스를 식별할 때는 주로 **호스트 이름**과 **경로**(Path)를 조합하여 사용한다. 이를 통해 동일한 IP 주소에서 여러 서비스나 리소스를 구분할 수 있다.

| **형식** | **설명** | **예시** |
| --- | --- | --- |
| 전체 URL (Full URL) | **프로토콜**과 **호스트**를 포함한 **전체 URL**을 사용 | GET https://www.example.com/products/12345 |
| 상대 경로 (Relative Path) | **경로**만을 사용하여 요청 | GET /products/12345 |
| 쿼리 스트링 (Query String) | **파라미터**를 포함하여 요청 조건을 전달 | GET /search?q=apple&category=fruit |
| 와일드카드 (*) | 특정 **경로**에 포함된 **모든 자원**을 요청 | GET /products/*, GET /images/*.jpg |
| 프래그먼트 (Fragment) | **자원의 특정 부분**을 요청하는 방식 | GET /about#team |

## 2.5) 서버에 임무를 부여하는 HTTP 메소드

### **HTTP 메소드 종류 및 특징**

| **메소드** | **설명** | **특징** | **사용 예시** |
| --- | --- | --- | --- |
| **GET** | 서버에서 자원을 **조회**할 때 사용. 자원에 대한 **읽기** 작업. | 서버 상태 변경 없음 (Idempotent, Safe). 캐싱 가능. | GET /products/12345 (제품 정보 조회) |
| **POST** | 서버에 자원을 **전송**하거나 **생성**할 때 사용. 자원에 대한 **작성** 작업. | 서버 상태 변경 있음. 멱등성 없음. 데이터 생성이나 제출 시 사용. | POST /users (새 사용자 생성) |
| **PUT** | 서버에 자원을 **업데이트**할 때 사용. 자원에 대한 **대체** 작업. | 자원 전체 교체. 멱등성(Idempotent). 동일 요청을 여러 번 보내도 결과 동일. | PUT /users/12345 (사용자 정보 업데이트) |
| **DELETE** | 서버에서 자원을 **삭제**할 때 사용. 자원에 대한 **제거** 작업. | 자원 삭제. 멱등성(Idempotent). 동일 요청을 여러 번 보내도 결과 동일. | DELETE /users/12345 (사용자 삭제) |
| **PATCH** | 서버에서 자원의 일부를 **수정**할 때 사용. 자원에 대한 **부분적 수정**. | 자원의 일부만 변경. 멱등성(Idempotent) 가능. | PATCH /users/12345 (사용자 정보 일부 업데이트) |
| **HEAD** | GET과 유사하나, 서버 응답에서 **헤더만**반환. **본문 없음**. | 서버 상태 변경 없음. 응답 본문 없음. 주로 메타데이터 조회. | HEAD /products/12345 (제품 헤더 조회) |
| **OPTIONS** | 서버가 지원하는 **메소드**를 확인할 때 사용. 자원에 대한 **지원 메소드**를 조회. | 서버에서 지원하는 HTTP 메소드 목록 반환. CORS에 사용. | OPTIONS /products/12345 (서버가 지원하는 메소드 조회) |
| **CONNECT** | 클라이언트와 서버 간 **터널링**을 설정할 때 사용. 주로 프록시 서버에서 사용. | SSL/TLS 연결 설정 시 사용. 주로 프록시 서버에서 사용. | CONNECT example.com:443(SSL 터널링 설정) |
| **TRACE** | 서버에서 **자기 진단**을 위해 요청을 그대로 응답으로 반환. | 요청을 그대로 반환하여 네트워크 경로 추적에 사용. 보안 상 이유로 비활성화될 수 있음. | TRACE /products/12345 (진단용 요청) |

## 멱등성(Idempotence)

**멱등성**이란 동일한 요청을 여러 번 보내도 **결과가 변하지 않고 동일**하다는 의미입니다. 즉, 요청을 여러 번 반복해도 서버의 상태는 처음 한 번의 요청과 동일하게 유지됩니다.

### **특징**

- 멱등성 메소드는 **같은 요청을 반복적으로 보내도 결과가 동일**하고 서버 상태는 변경되지 않거나 최초 요청 시와 동일하게 유지됩니다.
- 멱등성은 안전성(Safety)과는 다른 개념입니다. 안전성은 서버의 상태를 변경하지 않는다는 의미인 반면, 멱등성은 상태가 변경되더라도 결과가 동일하다는 뜻입니다.

### **멱등성 메소드 예시**

- **GET**: 서버의 자원을 **조회**하는 데 사용되므로, 동일한 GET 요청을 여러 번 보내도 서버의 상태가 변하지 않습니다.
- **PUT**: 자원의 **전체 교체**를 할 때 사용됩니다. 동일한 PUT 요청을 여러 번 보내도 **결과는 동일**하게 자원 전체가 같은 내용으로 교체됩니다.
- **DELETE**: 자원을 **삭제**하는 데 사용됩니다. 한 번 삭제된 자원을 다시 삭제해도 **결과는 동일**합니다.

## 비멱등성(Non-idempotence)

**비멱등성**은 동일한 요청을 여러 번 보내면 **서버의 상태가 계속 변**한다는 의미입니다. 즉, 동일한 요청을 여러 번 보내면 결과가 달라질 수 있습니다.

### **특징**

- 비멱등성 메소드는 **여러 번 요청을 보낼 때마다 서버의 상태가 바뀌거나 다른 결과를 초래**할 수 있습니다.
- 데이터의 **생성**, **변경** 등이 포함되어 여러 번의 요청마다 다른 결과가 발생할 수 있습니다.

### **비멱등성 메소드 예시**

- **POST**: 서버에 **새로운 자원**을 **생성**하는 데 사용됩니다. 동일한 POST 요청을 여러 번 보내면 새로운 자원이 **여러 번 생성**될 수 있습니다.

## TRACE 와 XSS

### **TRACE 메소드가 보안상 문제가 되는 이유**

**TRACE** 메소드는 원래 HTTP 요청을 **그대로 응답**으로 반환하는 방식이다. 이 기능은 서버가 **자기 진단**을 할 수 있도록 도와주지만, **보안** 상 문제가 될 수 있다. 특히 Cross-Site Scripting(XSS) 공격에 취약하여 많은 웹 서버에서는 **TRACE** 메소드를 비활성화하거나 제한한다.

### **XSS 공격 예시**

1. 공격자는 **악성 JavaScript 코드**를 포함한 HTTP **TRACE 요청**을 서버에 보낸다.
2. 서버는 이 요청을 **그대로 응답**으로 반환하며, 악성 스크립트가 포함된 응답을 클라이언트에게 전달한다.
3. 클라이언트는 서버로부터 받은 응답을 처리하며, **악성 스크립트**가 실행된다.
4. 이로 인해 사용자의 **세션 쿠키**를 탈취하거나 다른 악의적인 작업이 실행될 수 있다.

### **TRACE 요청과 응답 예시**

### 1. **TRACE 요청 예시**

클라이언트는 웹 서버에 TRACE 요청을 보내면, 서버는 클라이언트가 보낸 요청을 그대로 응답으로 반환한다.

```
TRACE /products/12345 HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0

```

### 2. TRACE 응답 예시 (XSS 공격)

서버가 이 요청을 그대로 응답으로 반환하면, 공격자가 요청에 악성 JavaScript 코드를 삽입했을 때, 이를 그대로 응답으로 받게 된다.

```

HTTP/1.1 200 OK
Date: Mon, 11 Feb 2025 12:00:00 GMT
Content-Type: message/http
Content-Length: 139

TRACE /products/12345 HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
<script>alert('XSS Attack');</script>

```

### **XSS 공격 흐름 설명**

1. 클라이언트(공격자)는 위와 같은 요청을 서버에 보낸다.
2. **서버**는 요청을 그대로 응답으로 반환하며, 공격자가 삽입한 `<script>` 태그와 악성 코드를 포함한 응답을 보낸다.
3. 사용자(클라이언트)는 이 응답을 받게 되며, **JavaScript**가 실행된다. 이때 실행되는 스크립트는 **세션 쿠키 탈취**, **사이트 포스팅** 등의 악성 작업을 수행할 수 있다.

### **보안상의 이유로 TRACE 메소드 비활성화**

대부분의 웹 서버는 **TRACE** 메소드가 **XSS 공격**을 유발할 수 있다는 이유로 비활성화하거나 제한한다. **TRACE**메소드는 **디버깅**과 **자기 진단** 용도로만 필요하며, 실제 운영 환경에서는 보안 위협이 될 수 있다.

### **웹 서버에서 TRACE 메소드 비활성화 예시**

- **Apache** 서버에서 TRACE 메소드를 비활성화:
    
    ```
    TraceEnable off
    ```
    
- **Nginx** 서버에서 TRACE 메소드를 비활성화:
    ```
    if ($request_method = TRACE)
    {
      return 405;
    }
    ```
